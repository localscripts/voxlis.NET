const Data = [
  {
    matcha: {
      main: {
        name: "Matcha",
        plat: ["windows"],
        desc: "Multi-feature external menu cheat",
        pros: [
          "Has a decompiler & code explorer",
          "Hybrid - kernel, usermode",
          "Rich in features",
        ],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://matcha.pink/discord",
        priceHref: "https://www.key-empire.com/#matcha",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$9.99",
        period: "lifetime",
      },
      flags: {
        hasKeySystem: false,
        pricegray: false,
        verified: true,
        external: true,
        premium: true,
        hideunc: true,
        free: false,
        hide: false,
      },
      modals: {
        info: "## Exploit Performance  \n- [Matcha]() is an external cheat featuring a built-in menu that provides access to preset functions such as ESP, Aimbot, Noclip, and other similar tools. It does not support standard Lua execution, as it uses a custom Lua environment that runs within the cheat rather than inside the game. [Matcha‚Äôs]() authentication system can be somewhat unintuitive, so the initial setup may require extra time. However, the registration process is somewhat complex and not user friendly.\n\n## Background Information  \n- Before [Matcha]() launched in August 2024, the project itself was relatively small and low-visibility. It originally started as a simple external tool but saw rapid improvement throughout mid-2024.  \n- After restructuring, [Matcha]() began receiving consistent daily updates‚Äîeven while [@Vault]() balanced school responsibilities. [@Vain]() was appointed to manage the staff team, improving coordination and overall structure. Staff operations are now organized, contributors are compensated, and the support team is publicly listed on the [Matcha Discord server]().  \n\n## Developer Background Information  \n- [Matcha]() is primarily developed by [@Vault](), who handles the core features and security. The project began when [@slamfrags]() asked [@Vault]() to create an external, which [Vault]() accepted partly due to financial needs.  \n- The initial management team consisted of [@geekn]() and [@slamfrags](); [@geekn]() left voluntarily, while [@slamfrags]() was later removed due to financial mismanagement and unprofessional conduct. Later on, [@slamfrags]() released his own external called [Yerba]().\n- After the removal, development accelerated and [@Vault]() brought trusted friends into the project, resulting in better structure, fair treatment of staff, and a more stable workflow.\n\n> Sources: [reddit.com/r/robloxhackers](https://reddit.com/r/robloxhackers), [voxlis.NET](https://voxlis.NET), Matcha Discord Moderators & Matcha Owner\n",
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          continue: "href",
        },
      },
    },
  },
  {
    potassium: {
      main: {
        name: "Potassium",
        plat: ["windows"],
        desc: "Best value execution solution",
        pros: ["Has a decompiler", "100% sUNC", "Level 8"],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://potassium.pro/",
        priceHref: "https://www.key-empire.com/#potassium",
        unclinks: {
          windows:
            "https://sunc.rubis.app/?scrap=p1oItowSFMvNrpuf&key=hzn8j0diRfPUuqfNpMUetdC8kWheuziL",
        },
      },
      misc: {
        editor: "voxlis.NET",
        price: "$19.99",
        period: "lifetime",
      },
      flags: {
        hasKeySystem: false,
        pricegray: false,
        verified: false,
        external: false,
        premium: true,
        hideunc: false,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Exploit Performance  \n- Works decently, but users have reported compatibility issues with [Potassium]().\n\n## Background Information  \n- There is no public background information for [Potassium]().\n\n## Developer Background  \n- The developers operate under fresh accounts, and their identities remain unknown. However, the quality of their product suggests this is not their first time creating similar tools. They may be using new aliases to avoid exposing their primary identities in the event of any issues or malicious activity, although the exact reason for their anonymity remains unclear.\n\n\n> Sources: [reddit.com/r/robloxhackers](https://reddit.com/r/robloxhackers) & [voxlis.NET](https://voxlis.NET)\n",
        warning: {
          enabled: true,
          icon: "cat.png",
          title: "Warning!",
          desc: "voxlis.NET recommends checking out 'MORE INFO' for Wave so you know what you're getting. Would you like to continue to Wave's website anyway?",
        },
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    wave: {
      main: {
        name: "Wave",
        plat: ["windows"],
        desc: "The best execution solution",
        pros: ["Has a decompiler", "100% sUNC", "Level 8"],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://getwave.gg/",
        priceHref: "https://www.key-empire.com/#wave",
        unclinks: {
          windows:
            "https://sunc.rubis.app/?scrap=chxc3Rtp1NOhSxAf&key=KwyQ9vNKHEL9lcCXWMNu7pFxpGrtki7q",
        },
      },
      misc: {
        editor: "voxlis.NET",
        price: "$7.49",
        period: "weekly",
      },
      flags: {
        hasKeySystem: false,
        pricegray: false,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    volcano: {
      main: {
        name: "Volcano",
        plat: ["windows"],
        desc: "Rich in history execution solution",
        pros: ["Has a decompiler", "94% sUNC", "Level 8"],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://volcano.wtf",
        priceHref: "https://www.key-empire.com/#volcano",
        unclinks: {
          windows:
            "https://sunc.rubis.app/?scrap=LQ8uphMkPlKrqKgY&key=wE4Rjq07vQ4dfsHh6a0dxX4A47q1ijaE",
        },
      },
      misc: {
        editor: "voxlis.NET",
        price: "$5.99",
        period: "weekly",
      },
      flags: {
        hasKeySystem: false,
        pricegray: true,
        verified: true,
        external: false,
        premium: false,
        hideunc: false,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Exploit Performance\n- [Volcano]() presents itself as a premium-quality product despite being free. However, the free version relies on a highly inconvenient key system that often feels designed to push users toward purchasing a bypass. As a result, the free tier functions more like a demo rather than something realistically usable without paying.\n\n## Background Information\n- [Volcano](), originally known as [Electron](), was created in December 2021. At the time, it wasn‚Äôt particularly notable and served mainly as an alternative used by a small subset of the community, especially since more popular options like [KRNL]() were available.\n- In June 2023, [Electron]() made a comeback with a UWP exploit. While they were not the first to achieve this method, they dominated the market significantly‚Äîlikely due to having more name recognition than competitors like [Celery](), which was relatively unknown. Their key system was easy to complete, but the key duration was inconsistent, lasting anywhere from an hour to a full day.\n- After UWP got a Byfron patch, some time later, [Electron]() was planned for release on December 1st on the Windows client, but delays pushed it back. It launched successfully, then became inactive, returned, functioned temporarily, and disappeared again‚Äîthough this period is not fully documented. After the second patch, communication largely stopped on their official Telegram, and their Discord was locked.\n- On April 22, 2024, they announced via Discord that [Electron]() would return under a new name: [Volcano](), with compensation for former [Electron]() users. It took time for [Volcano]() to regain traction, but it has since grown into a solid and active user base.\n- On December 11th, 2025, [Volcano]() ditched the key system and switched to a fully paid model since Byfron‚Äôs changes made updating tough, and tons of users were bypassing the keys, costing the owner a lot of potential money.\n\n## Developer Information\n- The main owner is [@coisop](), known for contributions to [Electron]() and [Volcano](). In 2019 work began on [RyoWrapper](), later renamed [RyoProto](); in 2020 [Neutron]() released as a paid LuaJIT wrapper; in 2021 [Electron]() launched as a free LuaJIT wrapper, the same year Luau dropped; [Electron]() eventually transitioned to [Proto Conversion]() with a Lua 5.1 to Luau transpiler; after the Luau source release the project continued using [Proto Conversion]() alongside direct Luau source integration; later development progressed into [Hyperion](), which remains in use today.\n\n\n\n\n> Sources: [reddit.com/r/robloxhackers](https://reddit.com/r/robloxhackers), [voxlis.NET](https://voxlis.NET) & The [Volcano]() Creator",
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    cryptic: {
      main: {
        name: "Cryptic",
        plat: ["windows", "macos", "ios", "android"],
        desc: "Great free execution solution",
        pros: ["Has a decompiler", "94% sUNC", "Level 8"],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://volcano.wtf",
        unclinks: {
          android:
            "https://sunc.rubis.app/?scrap=3ceXNUciuo4g64Ao&key=W0FJ6cRxGGbr19RFWXCiAjUMmYn4oUtw",
          macos:
            "https://sunc.rubis.app/?scrap=3ceXNUciuo4g64Ao&key=W0FJ6cRxGGbr19RFWXCiAjUMmYn4oUtw",
        },
      },
      misc: {
        editor: "voxlis.NET",
        price: "FREE",
      },
      flags: {
        hasKeySystem: true,
        pricegray: true,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: true,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Exploit Performance\n\n- [ NOTE ] { voxlis.NET } : To be tested\n\n## Background Information\n\n- [Cryptic](), originally released as an Android executor on December 7th, 2024, was not just another random pop-up executor; it became the first to achieve a verified 100% sUNC score. This achievement quickly established its reputation as a highly stable and reliable Android execution platform. Cryptic later entered a rough development period when its original developer transitioned to [Delta](), temporarily forcing the project to rely on the [Arceus X]() module. On November 28th, 2025, the team announced a full return to independence with the intent of restoring performance and refining user experience.\n\n- [Cryptic]() Windows released on December 27th, 2024, in partnership with [Argon](). The Windows version was later taken offline due to developer health concerns, with a confirmed relaunch scheduled for December 2025.\n\n- [Cryptic]() iOS launched on January 22nd, 2025, but had a short initial runtime due to development setbacks, with revival plans still active. [Cryptic]() macOS was released on November 17th, 2025, and contrary to speculation of discontinuation, the macOS build remains fully operational and continues receiving upkeep and optimization updates.\n\n## Developers Background Information\n- Kept private by the owners\n\n> Sources: [reddit.com/r/robloxhackers](https://reddit.com/r/robloxhackers), [voxlis.NET](https://voxlis.NET) & Cryptic Team",
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    severe: {
      main: {
        name: "Severe",
        plat: ["windows"],
        desc: "A good external exploit.",
        pros: [
          "Has a Luau environment",
          "Usermode product",
          "Rich in features",
        ],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://discord.gg/4QmWjQCgzV",
        priceHref: "https://discord.gg/4QmWjQCgzV",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$19.99",
        period: "lifetime",
      },
      flags: {
        hasKeySystem: false,
        pricegray: true,
        verified: false,
        external: true,
        premium: false,
        hideunc: true,
        free: false,
        hide: false,
        lvl: null,
      },
      modals: {
        info: "## Exploit Performance  \n- [Severe](/) gained recognition as the first undetected external  following the rollout of [Hyperion](/) in November 2023. Since then, it has undergone continuous improvements, focusing on stability, performance, and a user-friendly interface with clean, modern visuals.  \n- The custom [Luau](/) environment built into [Severe](/) is optimized for speed and deep memory interaction, offering advanced low-level capabilities rarely seen in external executors.\n\n## Background Information  \n- [Severe](/) originated as [v-severe](/), an external that began development before [Hyperion](/) was introduced, sometime around 2021.  \n- It now includes unique features such as a 3D radar and in-menu chat ‚Äî with additional enhancements planned for future releases.\n\n## Developers Background Information  \n- [Severe](/) is developed by [@BACKWOODS](/), who started his journey creating and redesigning UIs in C#. He later transitioned into exploit development, releasing [Sona](/) and [Sona One](/), two prior executors known for providing Level 6‚Äì7 execution performance.\n\n> Sources: [Severe](), internal testing, and developer notes\n",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    matrix: {
      main: {
        name: "Matrix",
        plat: ["windows"],
        desc: "A cheap external exploit.",
        pros: ["Usermode product", "Very cheap price"],
        neutral: ["Basic in features"],
        cons: [],
      },
      links: {
        href: "https://www.key-empire.com/#matrix",
        priceHref: "http://matrixhubs.shop/",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$4.99",
        period: "lifetime",
      },
      flags: {
        hasKeySystem: false,
        pricegray: true,
        verified: false,
        external: true,
        premium: false,
        hideunc: true,
        free: false,
        hide: false,
        lvl: null,
      },
      modals: {
        info: null,
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    ronin: {
      main: {
        name: "Ronin",
        plat: ["windows"],
        desc: "An external cheat with a Lifetime subscription.",
        pros: ["Amazing optimization", "Usermode product", "Rich in features"],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://getronin.xyz/",
        priceHref: "https://www.key-empire.com/#ronin",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$12.49",
        period: "lifetime",
      },
      flags: {
        hasKeySystem: false,
        pricegray: true,
        verified: false,
        external: true,
        premium: false,
        hideunc: true,
        free: false,
        hide: false,
        lvl: null,
      },
      modals: {
        info: "## Exploit Performance  \n- [Ronin]() is an external released on March 2nd, 2025. Recently out of beta, it performs on par with other fully released competitors. Since launch, [Ronin]() has delivered stable and reliable results, with minimal complaints from users and resellers.  \n- Despite being new, [Ronin]() has already proven itself in terms of stability, efficiency, and quality. Early feedback highlights its smooth performance and solid design. It is seen as a high-potential option with strong usability and readiness for the market.\n\n## Background Information  \n- [Ronin]() is a usermode product owned by [Reaper](), who also developed [Cryptic]() and [Somber]() (formerly known as [Reaper Hub]()). It officially released on March 2nd, 2025 and is currently out of beta. Development is now led by [@Pixi]() and [@Jumble](), after [Reaper]() stepped away from direct development.  \n- The interface is written in Rust, providing a fast and efficient user experience. [Ronin]() reflects the quality expected from [Reaper]()‚Äôs projects.  \n- [Reaper]() is known for maintaining a low profile, avoiding drama, and having a clean reputation in the community. His professionalism and consistent output have earned him wide respect.\n\n## Developer Background Information  \n- [Ronin]() is currently developed by [@Pixi]() and [@Jumble](), under the ownership of [Reaper]().  \n\n> Sources: [reddit.com/r/robloxhackers](), Ronin Discord Server\n",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    macsploit: {
      main: {
        name: "Macsploit",
        plat: ["macos"],
        desc: "A powerful exploit for macOS.",
        pros: [
          "Multi-Inject support",
          "Has a Trial version",
          "Has a decompiler",
          "100% sUNC",
          "Level 8",
        ],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://www.raptor.fun/",
        priceHref: "https://key-empire.com/#macsploit",
        unclinks: {
          macos:
            "https://sunc.rubis.app/?scrap=9kH1EN8HIbXl9I2o&key=KrU695V4fbJuWZcwG9jMJen2M22mRbng",
        },
      },
      misc: {
        editor: "voxlis.NET",
        price: "$9.99",
        period: "lifetime",
      },
      flags: {
        hasKeySystem: false,
        pricegray: true,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "\n## Exploit Performance\n- [MacSploit]() functions like a standard executor but is designed specifically for macOS. While its stability is generally acceptable, it has experienced significant periods of downtime. Since it is macOS-exclusive, [voxlis.NET]() cannot provide a deeper assessment at this time.\n\n## Background Information\n- In 2024, the [MacSploit]() source code was leaked by [@Peyton]() after [@managedhosts]() was accused of engaging in shady behavior, including alleged involvement with loggers and other suspicious practices.\n\n\n## Developer Information\n- [MacSploit](), owned by [Raptor](), was originally founded by [@Peyton]() and [@Nexus42](). Raptor initially began as a Windows executor collection. [@Peyton]() retired from the project in 2022 but later returned and reignited activity around [MacSploit]() following concerns about how the project was being handled.\n- [@Nexus42]() is currently the lead developer of [MacSploit](). However, he has a controversial reputation due to past involvement with logging tools, and the community remains critical of his role. Other contributors include [@atomic](), [@rcloll](), and [@Kohl](), who assist with the ongoing development of the project.  \n\n> Sources: [reddit.com/r/robloxhackers](), Raptor Development Discord, Raptor\n",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    yerba: {
      main: {
        name: "Yerba",
        plat: ["windows"],
        desc: "An external usermode product.",
        pros: ["Amazing optimization", "Usermode Product", "Has a decompiler "],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://yerba.wtf/",
        priceHref: "https://www.key-empire.com/#yerba",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$9.99",
        period: "lifetime",
      },
      flags: {
        hasKeySystem: false,
        pricegray: true,
        verified: false,
        external: true,
        premium: false,
        hideunc: true,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    codex: {
      main: {
        name: "CodeX",
        plat: ["android"],
        desc: "A powerful exploit with advanced features.",
        pros: ["Has a decompiler", "VNG Support", "Level 8"],
        neutral: ["Fails sUNC checks", "Uses core technology from ArceusX"],
        cons: [],
      },
      links: {
        href: "https://codex.lol/",
        priceHref: "https://key-empire.com/#codex",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$4.97",
        period: "monthly",
      },
      flags: {
        hasKeySystem: true,
        pricegray: true,
        verified: false,
        external: false,
        premium: false,
        hideunc: true,
        free: true,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Oops! ü§≠\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    hydrogen: {
      main: {
        name: "Hydrogen",
        plat: ["macos"],
        desc: "A free macOS Exploit",
        pros: ["Has a decompiler", "96% sUNC", "Level 8"],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://hydrogen.lat",
        priceHref: "https://hydrogen.lat",
        unclinks: {
          macos:
            "https://sunc.rubis.app/?scrap=5qh7GIfCDb8WZjtp&key=3Hq4Uz3Oc3X9G34ROz12ODY4VJIwXuUH",
        },
      },
      misc: {
        editor: "voxlis.NET",
        price: "$4.99",
        period: "monthly",
      },
      flags: {
        hasKeySystem: true,
        pricegray: true,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: true,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Exploit Performance\n- Customizable themes (open-source), [Luarmor]() support, and performance comparable to a standard executor.\n\n## Background Information\n- [Hydrogen]() has been a long-standing executor for macOS and Android (now discontinued). Originally developed by [@xgladius](), it was known for being an ultra-fast macOS executor. Later, development was taken over by [@retguard](), who eventually discontinued updates in May 2024 due to personal reasons. As of April 12, 2025, [@xgladius]() has resumed development, with plans to continue its progress for the foreseeable future.\n\n## Developer Background\n- [Hydrogen]() is created by [@xgladius](), a well-known exploit developer and reverse engineer. He is recognized for projects like [luaudec](https://github.com/xgladius/luauDec) and various other contributions to the Exploit Community.\n\n> Sources: Hydrogen Staff Team\n",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },

  {
    seliware: {
      main: {
        name: "Seliware",
        plat: ["windows"],
        desc: "A reliable exploit with excellent support.",
        pros: [
          "Multi-Inject support",
          "Has a decompiler",
          "100% sUNC",
          "Level 8",
        ],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://seliware.com",
        priceHref: "https://www.key-empire.com/#seliware",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$9.99",
        period: "monthly",
      },
      flags: {
        hasKeySystem: false,
        pricegray: false,
        verified: true,
        external: false,
        premium: true,
        hideunc: false,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Developers Background Information  \n- [Seliware](/) is developed by two experienced programmers ‚Äî [@Dx](/) and [@z33r0x](/). While little is publicly known about them, both were previously part of the development team behind [TRX](/), a widely used executor within the CIS scene before the Byfron update.\n\n## History  \n- During its closed beta phase, [Seliware](/) had four core developers: [@z33r0x](/), [@Dx](/), [@Nezy](/), and [@74235](/). However, [@Nezy](/) and [@74235](/) left the project shortly before launch, creating a competing product called [Calibri](/), which was discontinued soon after.  \n- Following its official release, [Seliware](/) introduced consistent updates and practical innovations. In January, after Microsoft patched the WinVerifyTrust hook injection method, [Seliware](/) was the third executor to push an update ‚Äî following [AWP](/) and [Wave](/).  \n- In April, due to internal issues, [Seliware](/) temporarily shut down for 3 weeks. Upon reopening, all active subscriptions were compensated. Currently, it stands as the most memory-efficient paid executor, making it especially appealing for farming use cases.\n\n## Future  \n- A complete rewrite of [Seliware](/) has been underway since December and will launch as a separate product under a new name. All users with an active [Seliware](/) subscription at the time of the new release will receive a full transfer.  \n- Support for other platforms ‚Äî including macOS and iOS ‚Äî is also planned for future expansion.\n\n## Interesting Facts  \n- [GRH](/), the creator of [Synapse Z](/), contributed to the early development of [Seliware](/).  \n- [Seliware](/) is the second-longest surviving internal executor following the [Hyperion](/) update, outlived only by [Wave](/).\n\n> Sources: [Seliware Team](), internal notes, and public release changelogs\n",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    bunni: {
      main: {
        name: "Bunni",
        plat: ["windows"],
        desc: "The free Level 8 exploit to use.",
        pros: ["Has a decompiler", "100% sUNC", "Level 8"],
        neutral: ["Check 'More Info' -> Exploit Performance"],
        cons: [],
      },
      links: {
        href: "https://discord.gg/bunnilol",
        priceHref: "https://www.key-empire.com/#bunni",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$34.99",
        period: "lifetime",
      },
      flags: {
        hasKeySystem: true,
        pricegray: true,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: true,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Exploit Performance\n\n* Multiple stability issues. You must have [VcRedist x64](https://aka.ms/vs/17/release/vc_redist.x64.exe) & [VcRedist x86](https://aka.ms/vs/17/release/vc_redist.x86.exe) installed to pass the UI, and a reasonably capable CPU. We tested this executor on an [i5-4460](). After the injection, the client‚Äôs performance dropped severely ‚Äî mouse and keyboard input lagged by roughly 20 seconds. Other executors do not show this behavior on the same CPU. [voxlis NETWORK]() recommends this executor only for lifetime-subscription users.\n\n\n## Background Information  \n\n- Originally released under the name [Swift](), the brand was later sold and the project renamed [Bunni](). It was subsequently rebranded to [Visual]() for a short period before returning to the [Bunni]() name. For a fuller timeline and source details, consult the Swift and MacSploit cards.\n\n\n## Developer Information  \n- [Peyton](/), the project‚Äôs creator, is an experienced and respected developer in the exploit community. His track record includes continued leadership on [Swift](/), while now also overseeing Visual‚Äôs direction. [Blinx](/), the UI designer behind both the original Swift interface and Visual‚Äôs current look, brings a clean and consistent visual identity across projects. [Reveny](/) and [Viz](/), both software engineering majors and longtime collaborators of Peyton, contribute to the development of Visual. Though not publicly known in the community, their technical expertise ensures the project is both scalable and dependable.\n\n> Sources: Reddit.com/r/robloxhackers, Swift Discord, Visual Discord, Bunni Discord",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },

  {
    solara: {
      main: {
        name: "Solara",
        plat: ["windows"],
        desc: "A free exploit with decent performance.",
        pros: ["Has a decompiler", "No keysystem", "51% sUNC~"],
        neutral: ["Level 3"],
        cons: [],
      },
      links: {
        href: "https://getsolara.dev",
        priceHref: null,
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "FREE",
        period: null,
      },
      flags: {
        hasKeySystem: false,
        pricegray: false,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: true,
        hide: false,
        lvl: 3,
      },
      modals: {
        info: "## Exploit Performance \n- [Solara]() offers solid performance with minimal crashes or instability, making it a reliable option for most users. It receives fast and frequent updates, keeping up with Roblox patches to reduce downtime.\n- Unlike many executors that rely on complicated key systems, [Solara]() simplifies access by requiring users to complete a quick Linkvertise task during download, making setup more user-friendly.\n\n## Background Information \n- [Solara]() is owned and managed by [@quivings](), who was previously active in the script development scene.\n- While not much is publicly known about him, [@quivings]() has built a respectable reputation within the community for his work and consistent updates to the tool.\n",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    delta: {
      main: {
        name: "Delta",
        plat: ["ios", "android"],
        desc: "A powerful multi-platform exploit.",
        pros: ["Has a decompiler", "100% sUNC", "Level 8"],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://deltaexploits.gg",
        priceHref: null,
        unclinks: {
          ios: "https://sunc.rubis.app/?scrap=YjWxOsGMMsBpfHlK&key=pZ1KPbSD5egMFjZT2wWV9vTU6iHirhhQ",
          android:
            "https://sunc.rubis.app/?scrap=YjWxOsGMMsBpfHlK&key=pZ1KPbSD5egMFjZT2wWV9vTU6iHirhhQ",
        },
      },
      misc: {
        editor: "voxlis",
        price: "FREE",
        period: null,
      },
      flags: {
        hasKeySystem: true,
        pricegray: false,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: true,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Oops! ü§≠\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    xeno: {
      main: {
        name: "Xeno",
        plat: ["windows"],
        desc: "A free exploit with basic features.",
        pros: ["Has a decompiler", "No keysystem", "40% sUNC~"],
        neutral: ["Level 3"],
        cons: [],
      },
      links: {
        href: "https://www.xeno.onl/",
        priceHref: "https://linkvertise.com/1319977/xeno",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "FREE",
        period: null,
      },
      flags: {
        hasKeySystem: false,
        pricegray: false,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: true,
        hide: false,
        lvl: 3,
      },
      modals: {
        info: "## Oops! ü§≠\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    serotonin: {
      main: {
        name: "Serotonin",
        plat: ["windows"],
        desc: "A usermode external exploit",
        pros: [
          "Has a Lua env & code explorer",
          "Usermode product",
          "Rich in features",
        ],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://serotonin.best/",
        priceHref: "https://key-empire.com/#serotonin",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$9.99",
        period: "monthly",
      },
      flags: {
        hasKeySystem: false,
        pricegray: true,
        verified: false,
        external: true,
        premium: false,
        hideunc: false,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "# Exploit Performance\n\n[Serotonin ](url)is an external cheat that has quickly gained a strong reputation from a development standpoint. It offers many unique features, including a **3D ESP Preview**, a **first** for external cheats on Roblox, which is fully modular, allowing all elements to be adjusted. Other notable features include a **Player Avatar/Mesh preview** to visualize meshes and players which has **never been done before**, and **Highlight/Mesh chams** that rival internal visuals. [Serotonin ](url)also provides a **globally functional vis check** and lighting modules that work in almost all games. The development team maintains a consistent weekly update schedule.\n\n## Background Information\n\n[Serotonin ](url)was launched by developer [@Auti](url), who branched off from a previous private project called **Melatonin**. During a year and a half at Melatonin, [Auti ](url)developed cheats for **Roblox, FiveM, Battlefield, CS:S, Rust DMA, and Apex DMA**. While there, [Auti](url) was responsible for releasing the **first external visibility check** to the public and enabling access to Instance Attributes through the external's Lua VM. When starting [Serotonin](url), [Auti](url) partnered with his friend [@Fope](url), who is the UI creator and designer for the menu. [Fope](url) plans on releasing his **CS:2** Product and eventually expanding onto other games.\n\n## Developer Insight\n\n- [Serotonin ](url)Roblox is developed by [Auti](url), who has approximately **five to six years of experience** in reverse engineering across numerous games. \n- Auti occasionally posts Devlogs to his [YouTube channel](https://www.youtube.com/@autihvh)\n- The UI and menu design are created by Fope, his partner.",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    vegax: {
      main: {
        name: "VegaX",
        plat: ["android"],
        desc: "A powerful exploit with short key duration.",
        pros: ["2 day long keys", "Level 8"],
        neutral: ["Fails sUNC checks", "Uses core technology from ArceusX"],
        cons: [],
      },
      links: {
        href: "https://vegax.gg",
        priceHref: "https://yap.com/",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "FREE",
        period: null,
      },
      flags: {
        hasKeySystem: true,
        pricegray: false,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: true,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Oops! ü§≠\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },

  {
    sirhurt: {
      main: {
        name: "SirHurt",
        plat: ["windows"],
        desc: "An exploit thats been around since 2015",
        pros: ["Has a decompiler", "97% sUNC", "Level 8"],
        neutral: [],
        cons: [],
      },
      links: {
        href: "https://sirhurt.net",
        priceHref: "https://sirhurt.net",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$2.80",
        period: "weekly",
      },
      flags: {
        hasKeySystem: false,
        pricegray: true,
        verified: false,
        external: false,
        premium: false,
        hideunc: false,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: '## Exploit Performance  \n- [SirHurt](https://sirhurt.net/) is a Level 8 executor with 93% sUNC compatibility. It performs consistently and supports a wide range of scripts.  \n\n## Background Information  \n- [SirHurt]() was originally launched in December 2015 as a private cheat under the name ‚ÄúAssHurt.‚Äù It was later renamed to "SirHurt" to make the product more marketable, particularly to younger users and their parents.  \n- Due to the shutdown of [V3rmillion.net](), much of its early history has been lost, though the executor has continued to receive updates and maintain relevance in the community for nearly a decade.  \n- The exploit is maintained by [IcePools](), who leads both development and operations. Past contributors include Woffle and Aero, though their current involvement is unclear.\n\n## Developer Background  \n- [IcePools]() is the main developer and operator of [SirHurt](). While there have been community warnings in the past‚Äîmainly regarding personal allegations‚Äîno verifiable evidence has been presented.  \n- A counter-CW was posted on [V3rm.net]() which addressed and debunked the original claims using archived material. The community generally considers the matter resolved.\n\n> Submitted by: **@daxhascool** (Public Relations at SirHurt)  \n> Sources: [reddit.com/r/robloxhackers]()\n',
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    aimmy: {
      main: {
        name: "Aimmy",
        plat: ["windows"],
        desc: "An AI-based exploit with support for multiple games.",
        pros: ["Supports other games", "No keysystem", "AI-based"],
        neutral: ["Requires GTX 1050 or better", "Requires training the model"],
        cons: [],
      },
      links: {
        href: "https://aimmy.dev",
        priceHref: "https://yap.com/",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "FREE",
        period: null,
      },
      flags: {
        hasKeySystem: false,
        pricegray: false,
        verified: false,
        external: true,
        premium: false,
        hideunc: true,
        free: true,
        hide: false,
        lvl: null,
      },
      modals: {
        info: "## Oops! ü§≠\n- Looks like we had not gathered the information yet on this Exploit! This could take some time to finish...\n\nIf you would like to help us out, visit https://github.com/localscripts/voxlis.NET/blob/main/README.md!",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
  {
    arceusx: {
      main: {
        name: "ArceusX",
        plat: ["ios", "android"],
        desc: "A long-standing mobile exploit.",
        pros: ["VNG Support", "Level 8"],
        neutral: ["Fails sUNC checks"],
        cons: [],
      },
      links: {
        href: "https://spdmteam.com/",
        priceHref: "https://www.key-empire.com/#arceusx",
        unclinks: {},
      },
      misc: {
        editor: "voxlis.NET",
        price: "$7.49",
        period: "monthly",
      },
      flags: {
        hasKeySystem: true,
        pricegray: true,
        verified: false,
        external: false,
        premium: false,
        hideunc: true,
        free: false,
        hide: false,
        lvl: 8,
      },
      modals: {
        info: "## Exploit Performance  \n- [ArceusX]() can run most scripts due to its high UNC percentage but lacks support for some functions like `getinstance`. Alternatives like [KRNL](https://krnl.cat) and [Delta](https://deltaexploits.gg) offer slightly better UNC and have safer reputations.\n\n## Background Information  \n- Released in 2019, [ArceusX]() was one of the first mobile Roblox executors. In March 2022, [@lxnny]() ‚Äî owner of [Delta](https://deltaexploits.gg) ‚Äî reposted a community warning on [WeAreDevs](https://wearedevs.net), exposing [ArceusX]() for ratting users and scamming developers. Despite this, it remains widely used. In April 2024, [SPDMTeam](https://spdmteam.com) launched [Wave](https://getwave.gg), a Windows executor combining [ArceusX]() and CodeX with an improved UI. While trusted, it‚Äôs still owned by the same team involved in past data issues. [ArceusX]() continues to receive regular updates.\n\n## Developer Background Information  \n- [ArceusX]() is owned by [Tiahh]() and [SPDMTeam](https://spdmteam.com). There is limited public information about the developers.\n\n> Sources: [reddit.com/r/robloxhackers]()\n",
        warning: null,
        downtime: {
          enabled: true,
          icon: "/assets/cat.png",
          title: "Hold on!",
          desc: "This exploit is currently not updated for {unupdated_platforms}! Would you like to still visit its website?",
          video: "https://www.youtube.com/watch?v=68Ra1IN19HU",
          continue: "href",
        },
      },
    },
  },
];

const BadgeData = [
  {
    id: "verified",
    label: "Verified",
    icon: '<i class="fas fa-check-circle"></i>',
    color: "#4374b3",
    backgroundColor: "rgba(6, 12, 25)",
    borderColor: "rgba(17, 36, 69)",
    hoverInfo:
      "This exploit contains full ‚ÄúMORE INFO‚Äù data and is confirmed as verified through corroborating background information.",
    tooltipBg: "#4374b3",
  },
  {
    id: "premium",
    label: "Best Value",
    icon: '<i class="fas fa-crown"></i>',
    color: "#fbbf24",
    backgroundColor: "rgba(251, 191, 36, 0.2)",
    borderColor: "rgba(251, 191, 36, 0.3)",
    hoverInfo:
      "The best-value product currently, based on community click data",
    tooltipBg: "#f59e0b",
  },
  {
    id: "warning",
    label: "Warning",
    icon: '<i class="fas fa-exclamation-triangle"></i>',
    color: "#ef4444",
    backgroundColor: "rgba(239, 68, 68, 0.2)",
    borderColor: "rgba(239, 68, 68, 0.3)",
    hoverInfo:
      "Warning: proceed carefully ‚Äî this exploit‚Äôs ‚ÄúMORE INFO‚Äù tab seems suspicious.",
    tooltipBg: "#dc2626",
  },
];

function getBadgeById(badgeId) {
  return BadgeData.find((b) => b.id === badgeId);
}

function determineBadgesForExploit(exploit) {
  const badges = [];

  // Check verified status
  if (exploit.verified === true) {
    badges.push("verified");
  }

  // Check premium status
  if (exploit.premium === true) {
    badges.push("premium");
  }

  // Check warning status
  if (exploit.warning && exploit.warning.enabled === true) {
    badges.push("warning");
  }

  return badges;
}

function convertData(data) {
  return data.map((exploitObj) => {
    const exploitKey = Object.keys(exploitObj)[0];
    const exploit = exploitObj[exploitKey];

    return {
      id: exploit.main.name.toLowerCase(),
      ...exploit.main,
      ...exploit.links,
      ...exploit.misc,
      ...exploit.flags,
      ...exploit.modals,
    };
  });
}

const expData = convertData(Data);

const configData = {
  theme: "dark",
  version: "1.2.3",
  _p1: "aHR0cHM6",
  debug: false,
  timeout: 5000,
};

const robloxVersionData = {
  windows: null,
  lastUpdated: null,
};

async function fetchRobloxVersion() {
  const response = await fetch("https://api.voxlis.net/roblox_version");
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const data = await response.json();
  robloxVersionData.windows = data.windows;
  robloxVersionData.lastUpdated = data.lastUpdated;
}

const globalStatusCache = new Map();
let statusCacheTimestamp = 0;
const STATUS_CACHE_DURATION = 5 * 60 * 1000;

async function computeFingerprint() {
  const fpData = [
    navigator.userAgent,
    navigator.language,
    screen.width + "x" + screen.height,
    Intl.DateTimeFormat().resolvedOptions().timeZone || "",
    navigator.platform,
  ].join("||");
  if (window.crypto && crypto.subtle && crypto.subtle.digest) {
    const enc = new TextEncoder();
    const buf = await crypto.subtle.digest("SHA-256", enc.encode(fpData));
    const arr = Array.from(new Uint8Array(buf));
    return arr.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  return fpData;
}

let globalClickCounts = {};

async function fetchAllExploitStatuses() {
  const now = Date.now();

  if (
    globalStatusCache.size > 0 &&
    now - statusCacheTimestamp < STATUS_CACHE_DURATION
  ) {
    return globalStatusCache;
  }

  const statusEndpoint = "https://api.voxlis.net/list"

  // Note from Riptxde: When testing locally, you can't make requests to the real API due to CORS
  // Instead, create a file called dummy_list_data.txt and fill it with data for testing,
  // or fill it with the real from api.voxlis.net/list
  // const statusEndpoint = "/dummy_list_data.txt";

  try {
    const response = await fetch(statusEndpoint);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const platformFirstData = await response.json();
    globalStatusCache.clear();
    statusCacheTimestamp = now;

    for (const exploit of expData) {
      const exploitStatuses = {};

      for (const platform of exploit.plat) {
        if (
          platformFirstData[platform] &&
          platformFirstData[platform][exploit.id]
        ) {
          const exploitData = platformFirstData[platform][exploit.id];
          exploitStatuses[platform] = exploitData.updated === true;
        } else {
          exploitStatuses[platform] = false;
        }
      }
      globalStatusCache.set(exploit.id, exploitStatuses);
    }

    return globalStatusCache;
  } catch (error) {
    console.error("Failed to fetch exploit statuses:", error);

    for (const exploit of expData) {
      const exploitStatuses = {};
      for (const platform of exploit.plat) {
        exploitStatuses[platform] = false;
      }
      globalStatusCache.set(exploit.id, exploitStatuses);
    }
    return globalStatusCache;
  }
}

async function getExploitStatus(exploitId) {
  if (globalStatusCache.has(exploitId)) {
    return globalStatusCache.get(exploitId);
  }

  await fetchAllExploitStatuses();

  return globalStatusCache.get(exploitId) || "unknown";
}

async function updateExploitStatusAndVersion(exploit) {
  return await getExploitStatus(exploit.id);
}

function getUnupdatedPlatformsString(exploitStatus) {
  if (!exploitStatus || typeof exploitStatus !== "object") {
    return "";
  }

  const platformNames = {
    windows: "Windows",
    macos: "macOS",
    ios: "iOS",
    android: "Android",
  };

  const unupdatedPlatforms = Object.entries(exploitStatus)
    .filter(([platform, isUpdated]) => !isUpdated)
    .map(([platform]) => platformNames[platform] || platform);

  if (unupdatedPlatforms.length === 0) {
    return "";
  } else if (unupdatedPlatforms.length === 1) {
    return unupdatedPlatforms[0];
  } else if (unupdatedPlatforms.length === 2) {
    return `${unupdatedPlatforms[0]} and ${unupdatedPlatforms[1]}`;
  } else {
    const lastPlatform = unupdatedPlatforms.pop();
    return `${unupdatedPlatforms.join(", ")}, and ${lastPlatform}`;
  }
}

class APIClient {
  constructor() {
    this.apiUrl = "https://api.voxlis.net/api.php";
    this.sessionId = "";
    this.sessionSecret = "";
    this.nonce = "";
    this.token = "";
    this.tokenExpiry = 0;
    this.initialized = false;
    this.powToken = "";
  }

  async initialize() {
    if (this.initialized) return;
    const res = await fetch(`${this.apiUrl}?action=init_session`, {
      method: "GET",
      credentials: "include",
    });
    if (!res.ok) throw new Error(`Session init failed: ${res.status}`);
    const data = await res.json();
    if (!data.success) throw new Error("Invalid session response");
    this.sessionId = data.data.session_id;
    this.sessionSecret = data.data.session_secret;
    this.nonce = data.data.nonce;
    this.powToken = data.data.pow_token || "";
    this.initialized = true;
  }

  async generateSignature(data) {
    if (!this.sessionSecret) throw new Error("Session secret not available");
    const encoder = new TextEncoder();
    const key = await crypto.subtle.importKey(
      "raw",
      encoder.encode(this.sessionSecret),
      { name: "HMAC", hash: "SHA-384" },
      false,
      ["sign"],
    );
    const signature = await crypto.subtle.sign(
      "HMAC",
      key,
      encoder.encode(data),
    );
    return Array.from(new Uint8Array(signature))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  async getToken() {
    if (!this.initialized) await this.initialize();
    const signature = await this.generateSignature(this.nonce);
    const headers = {
      "X-Session-Token": this.sessionId,
      "X-Nonce": this.nonce,
      "X-Signature": signature,
    };
    const res = await fetch(`${this.apiUrl}?action=get_token`, {
      method: "GET",
      credentials: "include",
      headers,
    });
    if (!res.ok) throw new Error(`Token fetch failed: ${res.status}`);
    const data = await res.json();
    if (!data.success) throw new Error("Invalid token response");
    this.token = data.data.token;
    this.tokenExpiry = data.data.expires;
    this.nonce = data.data.nonce;
    return this.token;
  }

  async solveProofOfWork() {
    if (!this.powToken) return "";
    const difficulty = 4;
    const target = "0".repeat(difficulty);
    const encoder = new TextEncoder();
    let nonceInt = 0;
    while (true) {
      const attempt = nonceInt.toString();
      const data = encoder.encode(this.powToken + attempt);
      const hashBuffer = await crypto.subtle.digest("SHA-256", data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
      if (hashHex.startsWith(target)) {
        return attempt;
      }
      nonceInt++;
    }
  }

  async trackClick(itemName, buttonType) {
    if (!this.initialized) await this.initialize();
    if (!this.token || Date.now() >= this.tokenExpiry * 1000) {
      await this.getToken();
    }
    const fingerprint = await this.generateFingerprint();
    let powNonce = "";
    if (this.powToken) {
      powNonce = await this.solveProofOfWork();
    }
    const headers = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${this.token}`,
      "X-Session-Token": this.sessionId,
      "X-Nonce": this.nonce,
    };
    try {
      const signature = await this.generateSignature(this.nonce);
      headers["X-Signature"] = signature;
    } catch (e) {
      console.error("Signature generation failed:", e);
      throw new Error("Security handshake failed");
    }
    if (this.powToken && powNonce) {
      headers["X-PoW-Token"] = this.powToken;
      headers["X-PoW-Nonce"] = powNonce;
    }
    const res = await fetch(this.apiUrl, {
      method: "POST",
      credentials: "include",
      headers,
      body: JSON.stringify({
        item: itemName,
        button_type: buttonType,
        fingerprint: fingerprint,
      }),
    });
    if (res.status === 401) {
      await this.getToken();
      return this.trackClick(itemName, buttonType);
    }
    if (res.status === 403) {
      throw new Error("Challenge required");
    }
    if (!res.ok) throw new Error(`API error: ${res.status}`);
    const data = await res.json();
    if (data.success && data.data.nonce) {
      this.nonce = data.data.nonce;
      await this.refreshClickCounts();
      return true;
    }
    throw new Error("Click tracking failed");
  }

  async fetchStats() {
    if (!this.initialized) await this.initialize();
    if (!this.token || Date.now() >= this.tokenExpiry * 1000) {
      await this.getToken();
    }
    const res = await fetch(`${this.apiUrl}?action=get_stats`, {
      method: "GET",
      credentials: "include",
      headers: {
        Authorization: `Bearer ${this.token}`,
        "X-Session-Token": this.sessionId,
        "X-Nonce": this.nonce,
      },
    });
    if (!res.ok) throw new Error(`Stats fetch failed: ${res.status}`);
    const data = await res.json();
    if (data.success && data.data.stats) {
      this.nonce = data.data.nonce || this.nonce;
      return data.data.stats;
    }
    throw new Error("Invalid stats response");
  }

  async refreshClickCounts() {
    const stats = await this.fetchStats();
    globalClickCounts = stats;
    if (
      window.uiManager &&
      typeof window.uiManager.updateCounts === "function"
    ) {
      window.uiManager.updateCounts();
    }
    return stats;
  }

  async generateFingerprint() {
    try {
      const parts = [
        navigator.userAgent,
        navigator.platform,
        screen.width + "x" + screen.height,
        new Date().getTimezoneOffset(),
        navigator.hardwareConcurrency || "",
        navigator.deviceMemory || "",
        screen.colorDepth,
      ].join("|");
      const buffer = new TextEncoder().encode(parts);
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    } catch {
      return "fp-" + Math.random().toString(36).substr(2, 10);
    }
  }
}

window.apiClient = new APIClient();

async function fetchClickCounts() {
  try {
    const stats = await window.apiClient.fetchStats();
    globalClickCounts = stats;
    return stats;
  } catch (e) {
    console.error("Error fetching click counts:", e);
    return {};
  }
}

function getTotalClicks(itemName) {
  const itemData = globalClickCounts[itemName];
  if (!itemData) return 0;
  return (itemData.website || 0) + (itemData.price || 0);
}

const performanceConfig = {
  maxFPS: 60,
  _p2: "Ly9hcGku",
  enableOptimizations: true,
  memoryLimit: 512,
};

class ClickTracker {
  constructor() {
    this.apiEndpoint = this._buildEndpoint();
    this.initialized = false;
    this.debugMode = false;
  }

  _buildEndpoint() {
    const fragments = [
      configData._p1,
      performanceConfig._p2,
      themeSettings._p3,
      debugSettings._p4,
    ];
    return atob(fragments.join(""));
  }

  init() {
    if (this.initialized) return;

    this.log("Initializing ClickTracker...");

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => {
        this.log("DOM loaded, setting up tracking...");
        this.setupTracking();
      });
    } else {
      this.log("DOM already ready, setting up tracking...");
      this.setupTracking();
    }

    this.initialized = true;
  }

  log(message, data = null) {
    if (this.debugMode) {
      console.log(`[ClickTracker] ${message}`, data || "");
    }
  }

  setupTracking() {
    this.log("Setting up click event listeners...");

    document.body.addEventListener(
      "click",
      (event) => {
        this.handleClick(event);
      },
      true,
    );

    this.setupMutationObserver();

    this.log("Click tracking setup complete");
  }

  setupMutationObserver() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === 1) {
              const webBtns = node.querySelectorAll
                ? node.querySelectorAll(".web-btn")
                : [];
              const priceBtns = node.querySelectorAll
                ? node.querySelectorAll(".prc-btn-new")
                : [];

              if (webBtns.length > 0 || priceBtns.length > 0) {
                this.log(
                  `New buttons detected: ${webBtns.length} web buttons, ${priceBtns.length} price buttons`,
                );
              }
            }
          });
        }
      });
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  }

  handleClick(event) {
    const target = event.target;
    const button = target.closest("button");

    if (!button) return;

    this.log("Button clicked:", button);

    let buttonType = null;
    let isTrackedButton = false;

    if (button.classList.contains("web-btn")) {
      buttonType = "website";
      isTrackedButton = true;
      this.log("Website button detected");
    } else if (button.classList.contains("prc-btn-new")) {
      buttonType = "price";
      isTrackedButton = true;
      this.log("Price button detected");
    }

    if (isTrackedButton) {
      this.handleButtonClick(button, buttonType, event);
    }
  }

  handleButtonClick(button, buttonType, event) {
    this.log(`Handling ${buttonType} button click`);

    const card = button.closest(".exp-crd") || button.closest(".exp-lst-itm");
    if (!card) {
      this.log("No parent card found");
      return;
    }

    this.log("Parent card found:", card);

    const itemName = this.getItemName(card);
    if (!itemName) {
      this.log("Could not extract item name");
      return;
    }

    this.log(`Extracted item name: "${itemName}"`);

    this.trackClick(itemName, buttonType);

    this.showClickFeedback(button, itemName, buttonType);
  }

  getItemName(card) {
    this.log("Extracting item name from card:", card);

    let itemName = card.getAttribute("data-name");
    if (itemName) {
      this.log(`Found item name from data-name: "${itemName}"`);
      return itemName;
    }

    const titleElement =
      card.querySelector(".crd-ttl") || card.querySelector(".lst-itm-ttl");
    if (titleElement) {
      const fullText = titleElement.textContent || titleElement.innerText || "";
      itemName = fullText
        .replace(/Verified|Premium|Warning|Updated|Down|Unknown|Untracked/g, "")
        .replace(/\s+/g, " ")
        .trim();

      this.log(`Found item name from title element: "${itemName}"`);
      return itemName;
    }

    const cardText = card.textContent || card.innerText || "";
    for (const exploit of expData) {
      if (cardText.includes(exploit.name)) {
        this.log(`Found item name by matching card content: "${exploit.name}"`);
        return exploit.name;
      }
    }

    this.log("Could not extract item name from card");
    return null;
  }

  async;
  trackClick(itemName, buttonType) {
    return window.apiClient.trackClick(itemName, buttonType);
  }

  showClickFeedback(button, itemName, buttonType) {
    const feedback = document.createElement("div");

    document.body.appendChild(feedback);

    setTimeout(() => {
      feedback.style.opacity = "1";
    }, 10);

    setTimeout(() => {
      feedback.style.opacity = "0";
      setTimeout(() => {
        if (feedback.parentNode) {
          feedback.parentNode.removeChild(feedback);
        }
      }, 300);
    }, 2000);
  }

  queueFailedClick(itemName, buttonType) {
    this.log(`Queueing failed click: ${buttonType} for "${itemName}"`);

    try {
      const failedClicks = JSON.parse(
        localStorage.getItem("failed_clicks") || "[]",
      );
      failedClicks.push({
        item: itemName,
        button_type: buttonType,
        timestamp: Date.now(),
      });
      localStorage.setItem("failed_clicks", JSON.stringify(failedClicks));
      this.log(`Queued failed click. Total queued: ${failedClicks.length}`);
    } catch (error) {
      this.log("Error queueing failed click:", error);
    }
  }

  async;
  retryFailedClicks() {
    this.log("Attempting to retry failed clicks...");

    try {
      const failedClicks = JSON.parse(
        localStorage.getItem("failed_clicks") || "[]",
      );
      if (failedClicks.length === 0) {
        this.log("No failed clicks to retry");
        return;
      }

      this.log(`Retrying ${failedClicks.length} failed clicks`);

      const retryPromises = failedClicks.map((click) =>
        this.trackClick(click.item, click.button_type),
      );

      Promise.allSettled(retryPromises);
      localStorage.removeItem("failed_clicks");
      this.log("‚úÖ Finished retrying failed clicks");
    } catch (error) {
      this.log("‚ùå Error retrying failed clicks:", error);
    }
  }

  testTracking() {
    this.log("Testing click tracking...");
    this.trackClick("Test Exploit", "website");
    this.trackClick("Test Exploit", "price");
  }
}

const themeSettings = {
  primaryColor: "#ff0000",
  _p3: "dm94bGlz",
  secondaryColor: "#00ff00",
  animations: true,
};

class PerformanceMonitor {
  constructor() {
    this.fps = 0;
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.memoryUsage = 0;
    this.deviceTier = "unknown";
    this.isLowEndDevice = false;
  }

  start() {
    this.checkDevicePerformance();
    this.monitorFPS();
    return this;
  }

  monitorFPS() {
    const updateFPS = () => {
      const now = performance.now();
      const elapsed = now - this.lastTime;

      if (elapsed >= 1000) {
        this.fps = Math.round((this.frameCount * 1000) / elapsed);
        this.frameCount = 0;
        this.lastTime = now;

        if (typeof performance.memory !== "undefined") {
          this.memoryUsage = performance.memory.usedJSHeapSize / (1024 * 1024);
        }
      }

      this.frameCount++;
      requestAnimationFrame(updateFPS);
    };

    requestAnimationFrame(updateFPS);
  }

  checkDevicePerformance() {
    const memoryScore = this.getMemoryScore();
    const cpuScore = this.getCPUScore();

    const totalScore = cpuScore * 0.7 + memoryScore * 0.3;

    if (totalScore < 30) {
      this.deviceTier = "low";
      this.isLowEndDevice = true;
    } else if (totalScore < 60) {
      this.deviceTier = "medium";
      this.isLowEndDevice = false;
    } else {
      this.deviceTier = "high";
      this.isLowEndDevice = false;
    }

    return this.deviceTier;
  }

  getCPUScore() {
    const samples = 3;
    let totalIterations = 0;

    for (let sample = 0; sample < samples; sample++) {
      const startTime = performance.now();
      let iterations = 0;

      while (performance.now() - startTime < 100) {
        for (let i = 0; i < 5000; i++) {
          Math.sqrt(Math.random() * 10000);
          Math.sin(Math.random() * Math.PI);
          Math.cos(Math.random() * Math.PI);
        }
        iterations++;
      }

      totalIterations += iterations;
    }

    const avgIterations = totalIterations / samples;
    return Math.min(100, avgIterations * 4);
  }

  getMemoryScore() {
    let memoryScore = 50;

    if (typeof navigator.deviceMemory !== "undefined") {
      memoryScore = Math.min(100, navigator.deviceMemory * 12.5);
    } else if (typeof performance.memory !== "undefined") {
      const totalJSHeapSize =
        performance.memory.jsHeapSizeLimit / (1024 * 1024);
      memoryScore = Math.min(100, totalJSHeapSize / 20);
    }

    return memoryScore;
  }
}

const debugSettings = {
  logLevel: "info",
  enableConsole: true,
  _p4: "Lm5ldC9jb3VudHMucGhw",
  showErrors: true,
};

class LazyLoader {
  constructor() {
    this.observer = null;
    this.initialized = false;
  }

  init() {
    if ("IntersectionObserver" in window) {
      this.observer = new IntersectionObserver(this.onIntersection.bind(this), {
        rootMargin: "200px",
        threshold: 0.1,
      });
      this.initialized = true;
    }
    return this;
  }

  observe(elements) {
    if (!this.initialized) return;

    if (elements instanceof NodeList || Array.isArray(elements)) {
      elements.forEach((el) => this.observer.observe(el));
    } else if (elements instanceof Element) {
      this.observer.observe(elements);
    }
  }

  onIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const element = entry.target;

        if (element.dataset.lazySrc) {
          element.src = element.dataset.lazySrc;
          delete element.dataset.lazySrc;
        }

        if (element.dataset.lazyBg) {
          element.style.backgroundImage = `url(${element.dataset.lazyBg})`;
          delete element.dataset.lazyBg;
        }

        if (element.classList.contains("lazy-load")) {
          element.classList.add("loaded");
          element.classList.remove("lazy-load");
        }

        this.observer.unobserve(element);
      }
    });
  }
}

class PaginationManager {
  constructor(containerSelector, itemCreator, dataSource, options = {}) {
    this.container = document.querySelector(containerSelector);
    this.itemCreator = itemCreator;
    this.dataSource = dataSource;
    this.options = {
      itemsPerPage: options.itemsPerPage || 9,
      ...options,
    };

    this.currentPage = 1;
    this.totalPages = 1;
    this.renderedItems = new Map();
    this.initialized = false;

    this.paginationContainer = document.getElementById("paginationContainer");
    this.prevBtn = document.getElementById("prevPageBtn");
    this.nextBtn = document.getElementById("nextPageBtn");
    this.pageNumbers = document.getElementById("pageNumbers");
    this.paginationInfo = document.getElementById("paginationInfo");
    this.pageInfo = document.getElementById("pageInfo");
  }

  init() {
    if (!this.container) return this;

    this.setupPaginationControls();
    this.render();
    this.initialized = true;

    return this;
  }

  setupPaginationControls() {
    if (this.prevBtn) {
      this.prevBtn.addEventListener("click", () => {
        if (this.currentPage > 1) {
          this.goToPage(this.currentPage - 1);
        }
      });
    }

    if (this.nextBtn) {
      this.nextBtn.addEventListener("click", () => {
        if (this.currentPage < this.totalPages) {
          this.goToPage(this.currentPage + 1);
        }
      });
    }
  }

  updateData(newData) {
    this.dataSource = newData;
    this.currentPage = 1;
    this.clear();
    this.render();
  }

  calculateTotalPages() {
    return Math.ceil(this.dataSource.length / this.options.itemsPerPage);
  }

  getCurrentPageData() {
    const startIndex = (this.currentPage - 1) * this.options.itemsPerPage;
    const endIndex = startIndex + this.options.itemsPerPage;
    return this.dataSource.slice(startIndex, endIndex);
  }

  goToPage(pageNumber) {
    if (pageNumber < 1 || pageNumber > this.totalPages) return;

    this.currentPage = pageNumber;
    this.clear();
    this.render();
  }

  render() {
    this.totalPages = this.calculateTotalPages();

    if (this.totalPages === 0) {
      this.hidePagination();
      return;
    }

    this.showPagination();

    const currentPageData = this.getCurrentPageData();
    const fragment = document.createDocumentFragment();

    this.container.innerHTML = "";

    currentPageData.forEach((data, index) => {
      const element = this.itemCreator(data, index);
      if (element) {
        fragment.appendChild(element);
      }
    });

    this.container.appendChild(fragment);
    this.updatePaginationControls();
    this.updatePageInfo();
  }

  updatePaginationControls() {
    if (this.prevBtn) {
      this.prevBtn.disabled = this.currentPage === 1;
    }

    if (this.nextBtn) {
      this.nextBtn.disabled = this.currentPage === this.totalPages;
    }

    if (this.pageNumbers) {
      this.pageNumbers.innerHTML = "";

      const maxVisiblePages = 5;
      let startPage = Math.max(
        1,
        this.currentPage - Math.floor(maxVisiblePages / 2),
      );
      const endPage = Math.min(
        this.totalPages,
        startPage + maxVisiblePages - 1,
      );

      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }

      if (startPage > 1) {
        this.addPageButton(1);
        if (startPage > 2) {
          this.addEllipsis();
        }
      }

      for (let i = startPage; i <= endPage; i++) {
        this.addPageButton(i);
      }

      if (endPage < this.totalPages) {
        if (endPage < this.totalPages - 1) {
          this.addEllipsis();
        }
        this.addPageButton(this.totalPages);
      }
    }

    if (this.paginationInfo) {
      this.paginationInfo.textContent = `Page ${this.currentPage} of ${this.totalPages}`;
    }
  }

  addPageButton(pageNumber) {
    const button = document.createElement("button");
    button.className = `page-number ${pageNumber === this.currentPage ? "active" : ""}`;
    button.textContent = pageNumber;
    button.addEventListener("click", () => this.goToPage(pageNumber));
    this.pageNumbers.appendChild(button);
  }

  addEllipsis() {
    const ellipsis = document.createElement("span");
    ellipsis.className = "page-ellipsis";
    ellipsis.textContent = "...";
    this.pageNumbers.appendChild(ellipsis);
  }

  updatePageInfo() {
    if (this.pageInfo) {
      const startItem = (this.currentPage - 1) * this.options.itemsPerPage + 1;
      const endItem = Math.min(
        this.currentPage * this.options.itemsPerPage,
        this.dataSource.length,
      );
      this.pageInfo.textContent = ` (${startItem}-${endItem})`;
    }
  }

  showPagination() {
    if (this.paginationContainer && this.totalPages > 1) {
      this.paginationContainer.style.display = "block";
    }
  }

  hidePagination() {
    if (this.paginationContainer) {
      this.paginationContainer.style.display = "none";
    }
  }

  clear() {
    this.renderedItems.clear();
    if (this.container) {
      this.container.innerHTML = "";
    }
  }
}

class AppState {
  constructor() {
    this.view = "grid";
    this.query = "";
    this.platformFilters = [];
    this.levelFilters = [0, 0];
    this.priceFilter = "all";
    this.verifiedOnly = false;
    this.premiumOnly = false;
    this.externalOnly = false;
    this.executorOnly = false;
    this.keySystemOnly = false;
    this.noKeySystemOnly = false;
    this.updatedOnly = false;
    this.sortBy = "most-popular";
    this.filteredData = [];
    this.performanceMonitor = new PerformanceMonitor().start();
    this.lazyLoader = new LazyLoader().init();
    this.paginationManager = null;
    this.isLoading = false;
    this.scrollPosition = 0;
    this.isFilterDrawerOpen = false;
    this.clickTracker = new ClickTracker();
    this.clickDataLoaded = false;
    this.exploitStatuses = new Map();
    this.statusLoadTime = 0;
  }

  async init() {
    this.clickTracker.init();

    try {
      await fetchClickCounts();
      this.clickDataLoaded = true;
    } catch (error) {
      this.clickDataLoaded = false;
    }

    try {
      await fetchRobloxVersion();
    } catch (error) {
      console.warn("Failed to fetch Roblox version data:", error);
    }

    const statusStartTime = performance.now();
    await this.updateAllExploitStatuses();
    this.statusLoadTime = performance.now() - statusStartTime;

    this.filteredData = expData.filter((exp) => exp.hide !== true);
    this.filterExploits();

    return this;
  }

  async updateAllExploitStatuses() {
    try {
      const statusMap = await fetchAllExploitStatuses();

      for (const [exploitId, status] of statusMap) {
        this.exploitStatuses.set(exploitId, status);
      }
    } catch (error) {
      console.warn("Failed to update exploit statuses:", error);

      for (const exploit of expData) {
        this.exploitStatuses.set(exploit.id, "unknown");
      }
    }
  }

  getExploitStatus(exploitId) {
    const rawStatus = this.exploitStatuses.get(exploitId);

    if (rawStatus === "unknown") {
      return "unknown";
    }
    if (typeof rawStatus === "boolean") {
      return rawStatus ? "updated" : "down";
    }
    if (typeof rawStatus === "object" && rawStatus !== null) {
      const hasUpdatedPlatform = Object.values(rawStatus).some(
        (status) => status === true,
      );
      const allPlatformsDown = Object.values(rawStatus).every(
        (status) => status === false,
      );

      if (hasUpdatedPlatform) {
        return "updated";
      } else if (allPlatformsDown && Object.keys(rawStatus).length > 0) {
        return "down";
      }
    }
    return "unknown";
  }

  filterExploits() {
    this.filteredData = expData
      .filter((exp) => {
        if (exp.hide === true) return false;

        if (this.query) {
          const query = this.query.toLowerCase();
          const nameMatch = exp.name.toLowerCase().includes(query);
          const descMatch = exp.desc.toLowerCase().includes(query);
          const platformMatch =
            exp.plat &&
            exp.plat.some((platform) => platform.toLowerCase().includes(query));
          const uncMatch =
            exp.pros &&
            exp.pros.some(
              (pro) =>
                pro.toLowerCase().includes("unc") &&
                pro.toLowerCase().includes(query),
            );
          const uncNeutralMatch =
            exp.neutral &&
            exp.neutral.some(
              (neutral) =>
                neutral.toLowerCase().includes("unc") &&
                neutral.toLowerCase().includes(query),
            );

          if (
            !(
              nameMatch ||
              descMatch ||
              platformMatch ||
              uncMatch ||
              uncNeutralMatch
            )
          ) {
            return false;
          }
        }

        if (this.platformFilters.length > 0) {
          if (
            !this.platformFilters.some((platform) =>
              exp.plat.includes(platform),
            )
          ) {
            return false;
          }
        }

        if (this.levelFilters[1] !== 0) {
          if (exp.external === true) {
            return false;
          } else if (
            typeof exp.lvl === "undefined" ||
            exp.lvl !== this.levelFilters[1]
          ) {
            return false;
          }
        }

        if (this.priceFilter !== "all") {
          if (
            this.priceFilter === "free" &&
            exp.price !== "FREE" &&
            !exp.free
          ) {
            return false;
          }
          if (
            this.priceFilter === "paid" &&
            (exp.price === "FREE" || exp.free)
          ) {
            return false;
          }
        }

        if (this.verifiedOnly && !exp.verified) {
          return false;
        }

        if (this.premiumOnly && !exp.premium) {
          return false;
        }

        if (this.externalOnly && exp.external !== true) {
          return false;
        }

        if (this.executorOnly) {
          let isConsideredExternal = exp.external === true;
          if (typeof exp.external === "undefined") {
            isConsideredExternal =
              (exp.pros &&
                exp.pros.some((pro) =>
                  pro.toLowerCase().includes("external"),
                )) ||
              (exp.neutral &&
                exp.neutral.some((neutral) =>
                  neutral.toLowerCase().includes("external"),
                ));
          }
          if (isConsideredExternal) {
            return false;
          }
        }

        if (this.keySystemOnly && !exp.hasKeySystem) {
          return false;
        }

        if (this.noKeySystemOnly) {
          if (exp.hasKeySystem) {
            return false;
          }
          if (exp.price !== "FREE" && !exp.free) {
            return false;
          }
        }

        if (this.updatedOnly) {
          const rawStatus = this.exploitStatuses.get(exp.id);

          // If platform filters are active, check if the exploit is updated for those specific platforms
          if (this.platformFilters.length > 0 && typeof rawStatus === "object" && rawStatus !== null) {
            const isUpdatedForSelectedPlatforms = this.platformFilters.some(
              (platform) => rawStatus[platform] === true
            );
            if (!isUpdatedForSelectedPlatforms) {
              return false;
            }
          } else {
            // If no platform filters, use the general status check
            const status = this.getExploitStatus(exp.id);
            if (status !== "updated") {
              return false;
            }
          }
        }

        return true;
      })
      .sort((a, b) => {
        if (a.premium && !b.premium) return -1;
        if (!a.premium && b.premium) return 1;

        switch (this.sortBy) {
          case "recommended":
            return 0;
          case "most-popular":
            const clicksA = getTotalClicks(a.name);
            const clicksB = getTotalClicks(b.name);
            if (this.clickDataLoaded && clicksA !== clicksB) {
              return clicksB - clicksA;
            }
            return a.name.localeCompare(b.name);
          case "least-popular":
            return getTotalClicks(a.name) - getTotalClicks(b.name);
          case "price-asc":
            const priceA = this.extractPrice(a.price);
            const priceB = this.extractPrice(b.price);
            return priceA - priceB;
          case "price-desc":
            const priceDescA = this.extractPrice(a.price);
            const priceDescB = this.extractPrice(b.price);
            return priceDescB - priceDescA;
          case "level-desc":
            const levelA = a.lvl || 0;
            const levelB = b.lvl || 0;
            return levelB - levelA;
          case "name-asc":
            return a.name.localeCompare(b.name);
          default:
            return 0;
        }
      });

    return this.filteredData;
  }

  extractPrice(price) {
    if (price === "FREE") return 0;
    const numericPrice = Number.parseFloat(price.replace(/[^\d.]/g, ""));
    return isNaN(numericPrice) ? 0 : numericPrice;
  }

  comparePrices(a, b) {
    const getPriceValue = (price) => {
      if (Array.isArray(price)) {
        return Number.parseFloat(price[0].replace(/[^\d.]/g, "")) || 0;
      }
      return price === "FREE"
        ? 0
        : Number.parseFloat(price.replace(/[^\d.]/g, "")) || 0;
    };

    return getPriceValue(a.price) - getPriceValue(b.price);
  }

  saveScrollPosition() {
    this.scrollPosition =
      window.pageYOffset || document.documentElement.scrollTop;
  }

  restoreScrollPosition() {
    if (this.scrollPosition > 0) {
      window.scrollTo(0, this.scrollPosition);
    }
  }
}

class UIManager {
  constructor(appState) {
    this.appState = appState;
    this.elements = {};
    this.debounceTimers = {};
    this.isUpdating = false;
  }

  init() {
    this.initElements();
    this.setupEventListeners();
    this.updateCounts();
    this.initPaginationManager();
    this.createModals();
    this.setupDropdowns();
    this.initTextSwitching();
    this.updateScrollbarStyles();
    this.handleWindowResize();

    const levelVal = this.getElement("levelValue");
    const mobileLevelVal = this.getElement("mobileLevelValue");
    if (levelVal) levelVal.textContent = "ALL";
    if (mobileLevelVal) mobileLevelVal.textContent = "ALL";

    this.setDefaultSortOption();

    window.uiManager = this;

    return this;
  }

  setDefaultSortOption() {
    const sortSelect = this.getElement("sortSelect");
    const mobileSortSelect = this.getElement("mobileSortSelect");

    if (sortSelect) {
      sortSelect.value = "most-popular";
    }
    if (mobileSortSelect) {
      mobileSortSelect.value = "most-popular";
    }

    const dropdownOptions = document.querySelectorAll(
      '.custom-dropdown-option[data-value="most-popular"]',
    );
    dropdownOptions.forEach((option) => {
      const dropdown = option.closest(".custom-dropdown");
      if (dropdown) {
        const selected = dropdown.querySelector(
          ".custom-dropdown-selected span",
        );
        if (selected) {
          selected.textContent = "Most Popular";
        }
        dropdown
          .querySelectorAll(".custom-dropdown-option")
          .forEach((opt) => opt.classList.remove("selected"));
        option.classList.add("selected");
      }
    });
  }

  initElements() {
    const selectors = {
      header: "#hdr",
      hero: "#heroSec",
      menuToggle: "#mobMenuTgl",
      menu: "#mobMenu",
      search: "#srchInp",
      mobileSearch: "#mobSrchInp",
      clearButton: "#clrSrch",
      mobileClearButton: "#mobClrSrch",
      filterButton: "#fltrBtn",
      mobileFilterButton: "#mobFltrBtn",
      drawer: "#fltrDrwr",
      applyButton: "#applyFltrs",
      closeButton: "#fasfa-times",
      levelSlider: "#lvlSldr",
      mobileLevelSlider: "#mobLvlSldr",
      levelValue: "#lvlMaxVal",
      mobileLevelValue: "#mobLvlMaxVal",
      levelFill: "#lvlTrkFill",
      mobileLevelFill: "#mobLvlTrkFill",
      verifiedSwitch: "#vrfSwch",
      mobileVerifiedSwitch: "#mobVrfSwch",
      premiumSwitch: "#premSwch",
      mobilePremiumSwitch: "#mobPremSwch",
      externalSwitch: "#extSwch",
      mobileExternalSwitch: "#mobExtSwch",
      executorSwitch: "#execSwch",
      mobileExecutorSwitch: "#mobExecSwch",
      keySwitch: "#keySwch",
      mobileKeySwitch: "#mobKeySwch",
      noKeySwitch: "#noKeySwch",
      mobileNoKeySwitch: "#mobNoKeySwch",
      updatedSwitch: "#updatedSwch",
      mobileUpdatedSwitch: "#mobUpdatedSwch",
      sortSelect: "#srtSel",
      mobileSortSelect: "#mobSortSel",
      resetButton: "#rstFltrs",
      mobileResetButton: "#mobRstFltrs",
      resetAllButton: "#rstAllFltrs",
      grid: "#expsGrid",
      list: "#expsList",
      noResults: "#noRes",
      filteredCount: "#fltrdCnt",
      totalCount: "#ttlCnt",
      tabButtons: ".tab-trgr",
      tabContent: ".tab-cntnt",
      canvas: "#strCnv",
      loadingScreen: "#loadingScreen",
      loadingBar: "#loadingBar",
      logoTextGradient: ".logo-txt-grd",
      logoTextLight: ".logo-txt-lt",
      themeDropdown: "#themeDropdown",
      themeDropdownSelected: "#themeDropdownSelected",
      themeDropdownOptions: "#themeDropdownOptions",
    };

    for (const [key, selector] of Object.entries(selectors)) {
      if (selector.startsWith(".")) {
        this.elements[key] = document.querySelectorAll(selector);
      } else {
        this.elements[key] = document.getElementById(selector.substring(1));
      }
    }
  }

  getElement(key) {
    return this.elements[key];
  }

  debounce(func, wait, key) {
    return (...args) => {
      clearTimeout(this.debounceTimers[key]);
      this.debounceTimers[key] = setTimeout(() => func.apply(this, args), wait);
    };
  }

  setupEventListeners() {
    window.addEventListener("scroll", () => {
      const heroHeight = this.getElement("hero")
        ? this.getElement("hero").offsetHeight
        : 0;
      if (window.scrollY > 0) {
        this.getElement("header").classList.add("scrolled");
      } else {
        this.getElement("header").classList.remove("scrolled");
      }
    });

    this.setupSearchListeners();
    this.setupFilterDrawer();
    this.setupLevelSliders();
    this.setupPlatformFilters();
    this.setupPriceFilters();
    this.setupToggleSwitches();
    this.setupSortSelects();
    this.setupResetButtons();
    this.setupTabButtons();

    window.addEventListener(
      "resize",
      this.debounce(this.handleWindowResize.bind(this), 100, "resize"),
    );
  }

  setupSearchListeners() {
    const search = this.getElement("search");
    const mobileSearch = this.getElement("mobileSearch");
    const clearButton = this.getElement("clearButton");
    const mobileClearButton = this.getElement("mobileClearButton");

    const handleSearchInput = this.debounce(
      (e) => {
        this.appState.query = e.target.value;
        if (mobileSearch && e.target !== mobileSearch)
          mobileSearch.value = this.appState.query;
        if (search && e.target !== search) search.value = this.appState.query;
        if (clearButton)
          clearButton.classList.toggle("hidden", !this.appState.query);
        if (mobileClearButton)
          mobileClearButton.classList.toggle("hidden", !this.appState.query);
        this.updateExploits();
      },
      200,
      "search",
    );

    if (search) {
      search.addEventListener("input", handleSearchInput);
    }

    if (mobileSearch) {
      mobileSearch.addEventListener("input", handleSearchInput);
    }

    const clearSearch = () => {
      this.appState.query = "";
      if (search) search.value = "";
      if (mobileSearch) mobileSearch.value = "";
      if (clearButton) clearButton.classList.add("hidden");
      if (mobileClearButton) mobileClearButton.classList.add("hidden");
      this.updateExploits();
    };

    if (clearButton) {
      clearButton.addEventListener("click", clearSearch);
    }

    if (mobileClearButton) {
      mobileClearButton.addEventListener("click", clearSearch);
    }
  }

  setupFilterDrawer() {
    const filterButton = this.getElement("filterButton");
    const mobileFilterButton = this.getElement("mobileFilterButton");
    const drawer = this.getElement("drawer");
    const applyButton = this.getElement("applyButton");
    const closeButton = this.getElement("closeButton");

    const openDrawer = () => {
      this.appState.saveScrollPosition();
      this.appState.isFilterDrawerOpen = true;
      drawer.classList.add("open");
      document.body.style.overflow = "hidden";
      document.body.style.position = "fixed";
      document.body.style.top = `-${this.appState.scrollPosition}px`;
      document.body.style.width = "100%";
    };

    const closeDrawer = () => {
      this.appState.isFilterDrawerOpen = false;
      drawer.classList.remove("open");
      document.body.style.overflow = "";
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.width = "";

      setTimeout(() => {
        this.appState.restoreScrollPosition();
      }, 10);
    };

    if (filterButton && drawer) {
      filterButton.addEventListener("click", openDrawer);
    }

    if (mobileFilterButton && drawer) {
      mobileFilterButton.addEventListener("click", () => {
        openDrawer();
        const menu = this.getElement("menu");

        if (menu) menu.classList.add("hidden");
        document.body.classList.remove("menu-open");
      });
    }

    if (drawer) {
      const overlay = drawer.querySelector(".fltr-drwr-ovl");
      if (overlay) {
        overlay.addEventListener("click", closeDrawer);
      }
    }

    if (applyButton && drawer) {
      applyButton.addEventListener("click", closeDrawer);
    }

    if (closeButton && drawer) {
      closeButton.addEventListener("click", closeDrawer);
    }
  }

  setupLevelSliders() {
    const levelSlider = this.getElement("levelSlider");
    const mobileLevelSlider = this.getElement("mobileLevelSlider");

    const updateLevelSlider = (
      slider,
      value,
      isMobile,
      updateFilters = true,
    ) => {
      const levelVal = isMobile
        ? this.getElement("mobileLevelValue")
        : this.getElement("levelValue");
      const otherSlider = isMobile
        ? this.getElement("levelSlider")
        : this.getElement("mobileLevelSlider");
      const otherLevelVal = isMobile
        ? this.getElement("levelValue")
        : this.getElement("mobileLevelValue");
      const levelFill = isMobile
        ? this.getElement("mobileLevelFill")
        : this.getElement("levelFill");

      if (updateFilters) {
        this.appState.levelFilters = [0, value];
      }

      if (levelVal) levelVal.textContent = value === 0 ? "ALL" : value;
      if (otherSlider) otherSlider.value = value;
      if (otherLevelVal)
        otherLevelVal.textContent = value === 0 ? "ALL" : value;

      if (levelFill) {
        const percent = (value / slider.max) * 100;
        levelFill.style.width = `${percent}%`;
      }

      if (updateFilters) {
        this.updateExploits();
      }
    };

    if (levelSlider) {
      // Update UI on input (smooth visual feedback without snapping)
      levelSlider.addEventListener("input", (e) => {
        const rawValue = Number.parseFloat(e.target.value);
        const displayValue = Math.round(rawValue);
        updateLevelSlider(e.target, displayValue, false, false);
      });

      // Update filters on change (when user releases slider)
      levelSlider.addEventListener("change", (e) => {
        const currentValue = Number.parseFloat(e.target.value);
        const targetValue = Math.round(currentValue);

        // Animate the snap
        const startTime = performance.now();
        const duration = 200; // ms

        const animate = (currentTime) => {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);

          // Easing function (ease-out)
          const easeProgress = 1 - Math.pow(1 - progress, 3);

          const interpolatedValue =
            currentValue + (targetValue - currentValue) * easeProgress;
          e.target.value = interpolatedValue;

          updateLevelSlider(
            e.target,
            Math.round(interpolatedValue),
            false,
            progress === 1,
          );

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            e.target.value = targetValue;
          }
        };

        requestAnimationFrame(animate);
      });
    }

    if (mobileLevelSlider) {
      // Update UI on input (smooth visual feedback without snapping)
      mobileLevelSlider.addEventListener("input", (e) => {
        const rawValue = Number.parseFloat(e.target.value);
        const displayValue = Math.round(rawValue);
        updateLevelSlider(e.target, displayValue, true, false);
      });

      // Update filters on change (when user releases slider)
      mobileLevelSlider.addEventListener("change", (e) => {
        const currentValue = Number.parseFloat(e.target.value);
        const targetValue = Math.round(currentValue);

        // Animate the snap
        const startTime = performance.now();
        const duration = 200; // ms

        const animate = (currentTime) => {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);

          // Easing function (ease-out)
          const easeProgress = 1 - Math.pow(1 - progress, 3);

          const interpolatedValue =
            currentValue + (targetValue - currentValue) * easeProgress;
          e.target.value = interpolatedValue;

          updateLevelSlider(
            e.target,
            Math.round(interpolatedValue),
            true,
            progress === 1,
          );

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            e.target.value = targetValue;
          }
        };

        requestAnimationFrame(animate);
      });
    }
  }

  setupPlatformFilters() {
    document
      .querySelectorAll(
        ".cstm-chkbx input[data-pltf], .mob-pltf-chkbx input[data-pltf]",
      )
      .forEach((checkbox) => {
        checkbox.addEventListener("change", () => {
          const platform = checkbox.getAttribute("data-pltf");

          if (checkbox.checked) {
            if (!this.appState.platformFilters.includes(platform)) {
              this.appState.platformFilters.push(platform);
            }
          } else {
            this.appState.platformFilters =
              this.appState.platformFilters.filter((p) => p !== platform);
          }

          document
            .querySelectorAll(`[data-pltf="${platform}"]`)
            .forEach((cb) => {
              cb.checked = checkbox.checked;
            });

          this.updateExploits();
        });
      });
  }

  setupPriceFilters() {
    document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((button) => {
      button.addEventListener("click", () => {
        const price = button.getAttribute("data-prc");
        this.appState.priceFilter = price;

        document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((btn) => {
          btn.classList.remove("actv");
          if (btn.getAttribute("data-prc") === price) {
            btn.classList.add("actv");
          }
        });

        this.updateExploits();
      });
    });
  }

  setupToggleSwitches() {
    const setupSwitchPair = (mainSwitch, mobileSwitch, stateProperty) => {
      if (mainSwitch) {
        mainSwitch.addEventListener("change", () => {
          this.appState[stateProperty] = mainSwitch.checked;
          if (mobileSwitch) mobileSwitch.checked = mainSwitch.checked;

          if (stateProperty === "keySystemOnly" && mainSwitch.checked) {
            const noKeySwitch = this.getElement("noKeySwitch");
            if (noKeySwitch && noKeySwitch.checked) {
              noKeySwitch.checked = false;
              this.appState.noKeySystemOnly = false;
              const mobileNoKeySwitch = this.getElement("mobileNoKeySwitch");
              if (mobileNoKeySwitch) mobileNoKeySwitch.checked = false;
            }
          } else if (
            stateProperty === "noKeySystemOnly" &&
            mainSwitch.checked
          ) {
            const keySwitch = this.getElement("keySwitch");
            if (keySwitch && keySwitch.checked) {
              keySwitch.checked = false;
              this.appState.keySystemOnly = false;
              const mobileKeySwitch = this.getElement("mobileKeySwitch");
              if (mobileKeySwitch) mobileKeySwitch.checked = false;
            }
          }

          this.updateExploits();
        });
      }

      if (mobileSwitch) {
        mobileSwitch.addEventListener("change", () => {
          this.appState[stateProperty] = mobileSwitch.checked;
          if (mainSwitch) mainSwitch.checked = mobileSwitch.checked;

          if (stateProperty === "keySystemOnly" && mobileSwitch.checked) {
            const mobileNoKeySwitch = this.getElement("mobileNoKeySwitch");
            if (mobileNoKeySwitch && mobileNoKeySwitch.checked) {
              mobileNoKeySwitch.checked = false;
              this.appState.noKeySystemOnly = false;
              const noKeySwitch = this.getElement("noKeySwitch");
              if (noKeySwitch) noKeySwitch.checked = false;
            }
          } else if (
            stateProperty === "noKeySystemOnly" &&
            mobileSwitch.checked
          ) {
            const mobileKeySwitch = this.getElement("mobileKeySwitch");
            if (mobileKeySwitch && mobileKeySwitch.checked) {
              mobileKeySwitch.checked = false;
              this.appState.keySystemOnly = false;
              const keySwitch = this.getElement("keySwitch");
              if (keySwitch) keySwitch.checked = false;
            }
          }

          this.updateExploits();
        });
      }
    };

    setupSwitchPair(
      this.getElement("verifiedSwitch"),
      this.getElement("mobileVerifiedSwitch"),
      "verifiedOnly",
    );
    setupSwitchPair(
      this.getElement("premiumSwitch"),
      this.getElement("mobilePremiumSwitch"),
      "premiumOnly",
    );
    setupSwitchPair(
      this.getElement("externalSwitch"),
      this.getElement("mobileExternalSwitch"),
      "externalOnly",
    );
    setupSwitchPair(
      this.getElement("executorSwitch"),
      this.getElement("mobileExecutorSwitch"),
      "executorOnly",
    );
    setupSwitchPair(
      this.getElement("keySwitch"),
      this.getElement("mobileKeySwitch"),
      "keySystemOnly",
    );
    setupSwitchPair(
      this.getElement("noKeySwitch"),
      this.getElement("mobileNoKeySwitch"),
      "noKeySystemOnly",
    );
    setupSwitchPair(
      this.getElement("updatedSwitch"),
      this.getElement("mobileUpdatedSwitch"),
      "updatedOnly",
    );
  }

  setupSortSelects() {
    const sortSelect = this.getElement("sortSelect");
    const mobileSortSelect = this.getElement("mobileSortSelect");

    if (sortSelect) {
      sortSelect.addEventListener("change", () => {
        this.appState.sortBy = sortSelect.value;
        if (mobileSortSelect) mobileSortSelect.value = this.appState.sortBy;
        this.updateExploits();
      });
    }

    if (mobileSortSelect) {
      mobileSortSelect.addEventListener("change", () => {
        this.appState.sortBy = mobileSortSelect.value;
        if (sortSelect) sortSelect.value = this.appState.sortBy;
        this.updateExploits();
      });
    }
  }

  setupResetButtons() {
    const resetFilters = () => {
      this.appState.platformFilters = [];
      this.appState.levelFilters = [0, 0];
      this.appState.priceFilter = "all";
      this.appState.verifiedOnly = false;
      this.appState.premiumOnly = false;
      this.appState.externalOnly = false;
      this.appState.executorOnly = false;
      this.appState.keySystemOnly = false;
      this.appState.noKeySystemOnly = false;
      this.appState.updatedOnly = false;

      document
        .querySelectorAll(".cstm-chkbx input, .mob-pltf-chkbx input")
        .forEach((cb) => {
          cb.checked = false;
        });

      document.querySelectorAll(".prc-btn, .mob-prc-btn").forEach((btn) => {
        btn.classList.remove("actv");
        if (btn.getAttribute("data-prc") === "all") {
          btn.classList.add("actv");
        }
      });

      const levelSlider = this.getElement("levelSlider");
      const mobileLevelSlider = this.getElement("mobileLevelSlider");
      const levelVal = this.getElement("levelValue");
      const mobileLevelVal = this.getElement("mobileLevelValue");

      if (levelSlider) levelSlider.value = 0;
      if (mobileLevelSlider) mobileLevelSlider.value = 0;
      if (levelVal) levelVal.textContent = "ALL";
      if (mobileLevelVal) mobileLevelVal.textContent = "ALL";

      const levelFill = this.getElement("levelFill");
      const mobileLevelFill = this.getElement("mobileLevelFill");
      if (levelFill) levelFill.style.width = "0%";
      if (mobileLevelFill) mobileLevelFill.style.width = "0%";

      const switches = [
        "verifiedSwitch",
        "mobileVerifiedSwitch",
        "premiumSwitch",
        "mobilePremiumSwitch",
        "externalSwitch",
        "mobileExternalSwitch",
        "executorSwitch",
        "mobileExecutorSwitch",
        "keySwitch",
        "mobileKeySwitch",
        "noKeySwitch",
        "mobileNoKeySwitch",
        "updatedSwitch",
        "mobileUpdatedSwitch",
      ];

      switches.forEach((switchKey) => {
        const switchElement = this.getElement(switchKey);
        if (switchElement) switchElement.checked = false;
      });

      this.updateExploits();
    };

    const resetButtons = [
      this.getElement("resetButton"),
      this.getElement("mobileResetButton"),
      this.getElement("resetAllButton"),
    ];

    resetButtons.forEach((button) => {
      if (button) {
        button.addEventListener("click", resetFilters);
      }
    });
  }

  setupTabButtons() {
    const tabButtons = this.getElement("tabButtons");
    const tabContent = this.getElement("tabContent");

    if (tabButtons && tabButtons.length) {
      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const tab = button.getAttribute("data-tab");
          this.appState.view = tab;

          tabButtons.forEach((btn) => btn.classList.remove("actv"));
          button.classList.add("actv");

          if (tabContent && tabContent.length) {
            tabContent.forEach((content) => content.classList.remove("actv"));
            const activeContent = document.getElementById(`${tab}Tab`);
            if (activeContent) activeContent.classList.add("actv");
          }

          this.updateExploits();
        });
      });
    }
  }

  initPaginationManager() {
    const grid = this.getElement("grid");

    if (grid) {
      this.appState.paginationManager = new PaginationManager(
        "#expsGrid",
        this.createCard.bind(this),
        this.appState.filteredData,
        {
          itemsPerPage: 9,
        },
      ).init();
    }
  }

  updateExploits() {
    if (this.isUpdating) return;
    this.isUpdating = true;

    requestAnimationFrame(() => {
      try {
        const filteredData = this.appState.filterExploits();
        const noResults = this.getElement("noResults");

        if (filteredData.length === 0) {
          if (noResults) noResults.classList.remove("hidden");
        } else {
          if (noResults) noResults.classList.add("hidden");
        }

        if (this.appState.paginationManager && this.appState.view === "grid") {
          this.appState.paginationManager.updateData(filteredData);
        }

        this.updateCounts();

        setTimeout(() => {
          this.setupCardButtons();
          this.isUpdating = false;
        }, 50);
      } catch (error) {
        console.error("Error updating exploits:", error);
        this.isUpdating = false;
      }
    });
  }

  createCard(exploit) {
    const card = document.createElement("div");
    card.className = "exp-crd";
    if (exploit.premium) card.classList.add("prem");

    card.setAttribute("data-id", exploit.id);
    card.setAttribute("data-name", exploit.name);

    const accentColor = exploit.premium ? "prem" : exploit.accentColor;
    let levelDisplay = "";
    if (exploit.external === true) {
      levelDisplay = `<div class="lvl-bdg ${exploit.txtColor}">External</div>`;
    } else if (typeof exploit.lvl !== "undefined") {
      levelDisplay = `<div class="lvl-bdg ${exploit.txtColor}">Level ${exploit.lvl}</div>`;
    }

    const status = this.appState.getExploitStatus(exploit.id);
    let statusClass = "untracked";
    switch (status) {
      case "updated":
        statusClass = "updated";
        break;
      case "down":
        statusClass = "down";
        break;
      case "unknown":
        statusClass = "unknown";
        break;
    }
    card.classList.add(`status-${statusClass}`);

    let badgesHtml = "";
    if (exploit.verified) {
      const badgeData = getBadgeById("verified");
      badgesHtml += `<span class="vrf-bdg" style="--badge-color: ${badgeData.color}; --badge-bg: ${badgeData.backgroundColor}; --badge-border: ${badgeData.borderColor}; --tooltip-bg: ${badgeData.tooltipBg};">${badgeData.icon}${badgeData.label}<span class="badge-tooltip-text">${badgeData.hoverInfo}</span></span>`;
    }
    if (exploit.premium) {
      const badgeData = getBadgeById("premium");
      badgesHtml += `<span class="prem-bdg" style="--badge-color: ${badgeData.color}; --badge-bg: ${badgeData.backgroundColor}; --badge-border: ${badgeData.borderColor}; --tooltip-bg: ${badgeData.tooltipBg};">${badgeData.icon}${badgeData.label}<span class="badge-tooltip-text">${badgeData.hoverInfo}</span></span>`;
    }
    if (exploit.warning?.enabled === true) {
      const badgeData = getBadgeById("warning");
      badgesHtml += `<span class="warn-bdg" style="--badge-color: ${badgeData.color}; --badge-bg: ${badgeData.backgroundColor}; --badge-border: ${badgeData.borderColor}; --tooltip-bg: ${badgeData.tooltipBg};">${badgeData.icon}${badgeData.label}<span class="badge-tooltip-text">${badgeData.hoverInfo}</span></span>`;
    }

    card.innerHTML = `
<div class="crd-acnt ${accentColor}"></div>
<div class="crd-hdr">
<div class="crd-hdr-cntnt">
  <div class="crd-ttl-cntr">
    <h3 class="crd-ttl">
      ${exploit.name}
      ${badgesHtml}
    </h3>
    <p class="crd-desc">${exploit.desc}</p>
  </div>
  <div class="pltf-bdgs">
    ${this.renderPlatformBadges(exploit)}
  </div>
</div>
</div>
<div class="crd-bdy">
<div class="crd-meta">
  ${levelDisplay}
  <div class="meta-sep"></div>
  <div class="edr-info">Last edited by ${exploit.editor}</div>
</div>
<div class="crd-cntnt cstm-scrlbr">
  ${this.renderFeatureSection(exploit.pros, "pros", "+")}
  ${this.renderFeatureSection(exploit.neutral, "ntrl", "‚Ä¢")}
  ${this.renderFeatureSection(exploit.cons, "cons", "-")}
</div>
</div>
<div class="crd-ftr">
${this.renderCardFooter(exploit)}
</div>
`;

    return card;
  }

  renderPlatformBadges(exploit) {
    const statuses = this.appState.exploitStatuses.get(exploit.id) || {};

    const getStatusInfo = (platform) => {
      let status = "untracked";
      if (
        typeof statuses === "object" &&
        statuses !== null &&
        statuses.hasOwnProperty(platform)
      ) {
        status = statuses[platform] ? "updated" : "down";
      } else if (statuses === true) {
        status = "updated";
      } else if (statuses === false) {
        status = "down";
      } else if (statuses === "unknown") {
        status = "unknown";
      }
      const statusText = status.charAt(0).toUpperCase() + status.slice(1);
      return {
        className: `status-${status}`,
        text: statusText,
        status: status,
      };
    };

    const uniquePlatforms = [...new Set(exploit.plat)];

    // Build platform badge objects with their status
    const platformBadges = uniquePlatforms
      .map((platform) => {
        const statusInfo = getStatusInfo(platform);
        let iconHtml = "";
        let platformName = "";

        switch (platform) {
          case "windows":
            iconHtml = `<i class="fab fa-windows"></i>`;
            platformName = "Windows";
            break;
          case "macos":
            iconHtml = `<img src="/assets/macos.svg" alt="macOS" style="width:16px; height:16px; vertical-align:middle;">`;
            platformName = "macos";
            break;

          case "android":
            iconHtml = `<i class="fab fa-android"></i>`;
            platformName = "Android";
            break;
          case "ios":
            iconHtml = `<i class="fab fa-apple"></i>`;
            platformName = "iOS";
            break;
        }

        if (iconHtml) {
          const tooltipText = `${platformName} | ${statusInfo.text}`;
          return {
            iconHtml: iconHtml,
            tooltipText: tooltipText,
            className: statusInfo.className,
            status: statusInfo.status,
            priority:
              statusInfo.status === "updated"
                ? 0
                : statusInfo.status === "down"
                  ? 1
                  : 2,
          };
        }
        return null;
      })
      .filter((badge) => badge !== null);

    // Sort badges: updated first (priority 0), then down (priority 1), then others (priority 2)
    platformBadges.sort((a, b) => a.priority - b.priority);

    // Separate badges into updated and status-down groups
    const updatedBadges = platformBadges.filter((badge) => badge.status === "updated");
    const downBadges = platformBadges.filter((badge) => badge.status === "down");
    const otherBadges = platformBadges.filter((badge) => badge.status !== "updated" && badge.status !== "down");

    // Render updated badges
    let badges = "";
    updatedBadges.forEach((badge) => {
      badges += `
          <div class="pltf-bdg ${badge.className}">
              ${badge.iconHtml}
              <span class="platform-tooltip">${badge.tooltipText}</span>
          </div>`;
    });

    // Render other badges (untracked, unknown)
    otherBadges.forEach((badge) => {
      badges += `
          <div class="pltf-bdg ${badge.className}">
              ${badge.iconHtml}
              <span class="platform-tooltip">${badge.tooltipText}</span>
          </div>`;
    });

    // Render status-down badges in their own container
    if (downBadges.length > 0) {
      badges += `<div class="pltf-bdgs-down">`;
      downBadges.forEach((badge) => {
        badges += `
            <div class="pltf-bdg ${badge.className}">
                ${badge.iconHtml}
                <span class="platform-tooltip">${badge.tooltipText}</span>
            </div>`;
      });
      badges += `</div>`;
    }

    // Add key system badge at the end
    if (exploit.hasKeySystem) {
      badges += `
        <a href="https://www.youtube.com/watch?v=KKshbStBH_g" target="_blank" rel="noopener noreferrer" class="pltf-bdg key-system">
            <i class="fas fa-key key-icon"></i>
            <i class="fab fa-youtube youtube-icon"></i>
            <span class="platform-tooltip">Has Key System</span>
        </a>`;
    }

    return badges;
  }

  renderFeatureSection(features, className, icon) {
    if (!features || features.length === 0) return "";

    return `
<div class="feat-sec ${className}">
<h4 class="feat-hdng">
  <span class="feat-ico">${icon}</span>
  ${className === "pros" ? "Pros" : className === "ntrl" ? "Neutral" : "Cons"}
</h4>
<ul class="feat-lst">
  ${features.map((feature) => `<li class="feat-itm">${feature}</li>`).join("")}
</ul>
</div>
`;
  }

  renderExtraButtonIcon(iconString) {
    if (!iconString || iconString.trim() === "") {
      return "";
    }

    const googleFontIcons = [
      "star",
      "favorite",
      "home",
      "settings",
      "search",
      "menu",
      "close",
      "check",
      "arrow_forward",
      "download",
      "upload",
      "delete",
      "edit",
      "add",
      "shopping_cart",
      "account_circle",
      "info",
      "warning",
      "error",
      "success",
      "help",
      "visibility",
      "lock",
      "unlock",
      "share",
      "send",
      "mail",
      "notifications",
      "more_vert",
      "more_horiz",
      "refresh",
      "sync",
      "cloud_download",
      "cloud_upload",
      "trending_up",
      "trending_down",
      "grade",
      "thumb_up",
      "thumb_down",
      "comment",
      "forum",
      "people",
      "person",
      "public",
      "build",
      "code",
      "language",
      "style",
    ];

    if (googleFontIcons.includes(iconString.toLowerCase())) {
      return `<span class="material-icons-round">${iconString}</span>`;
    }

    return `<i class="fas fa-${iconString}"></i>`;
  }

  renderExtraButton(exploit) {
    if (!exploit.extrabutton || !exploit.extrabutton.enabled) {
      return "";
    }

    const config = exploit.extrabutton;

    if (config.swap === true) {
      return ""; // Handled by UNC button replacement
    }

    // If swap is false, render inline extra button next to weekly price
    const iconHTML = this.renderExtraButtonIcon(config.icon);
    const buttonText = config.text || "EXTRA";

    return `
      <button class="crd-btn extra-btn-inline" style="
        border: 1px solid ${config.outlinecolor};
        background-color: rgba(${this.hexToRgb(config.outlinecolor).r}, ${this.hexToRgb(config.outlinecolor).g}, ${this.hexToRgb(config.outlinecolor).b}, 0.1);
        color: ${config.outlinecolor};
      ">
        ${buttonText}
        ${iconHTML ? `<span class="extra-btn-icon">${iconHTML}</span>` : ""}
      </button>
    `;
  }

  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
      ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16),
        }
      : { r: 255, g: 255, b: 255 };
  }

  renderCardFooter(exploit) {
    const websiteButtonText =
      exploit.websitetext || (exploit.websitetofree ? "Free" : "Website");

    if (exploit.price === "FREE") {
      if (exploit.hideunc === true) {
        return `
      <div class="btn-grid free-program-grid">
        <button class="crd-btn info-btn full-width">
          <div class="text-container">
            <span class="text-switch visible" data-text="info">INFO</span>
            <span class="text-switch hidden" data-text="more">MORE</span>
          </div>
          <i class="fas fa-info-circle"></i>
        </button>
      </div>
      ${this.renderExtraButton(exploit)}
      ${(() => {
        let displayDomain = websiteButtonText;
        if (exploit.href) {
          try {
            const url = new URL(exploit.href);
            displayDomain = url.hostname.replace(/^www\./, "");
          } catch (e) {
            displayDomain = exploit.href
              .replace(/^https?:\/\/(www\.)?/, "")
              .split("/")[0];
          }
        }
        return `<button class="crd-btn web-btn full-width">
          <div class="default-text">
            <i class="fas fa-external-link-alt"></i> ${websiteButtonText}
          </div>
          <div class="hover-text">
            <i class="fas fa-external-link-alt"></i> ${displayDomain}
          </div>
        </button>`;
      })()}
    `;
      } else {
        const hasExtraButtonWithSwap =
          exploit.extrabutton &&
          exploit.extrabutton.enabled &&
          exploit.extrabutton.swap === true;
        const uncConfig = hasExtraButtonWithSwap ? exploit.extrabutton : null;

        const uncButtonHTML = hasExtraButtonWithSwap
          ? `
          <button class="crd-btn unc-btn expanded" style="
            border: 1px solid ${uncConfig.outlinecolor};
            background-color: rgba(${this.hexToRgb(uncConfig.fillercolor).r}, ${this.hexToRgb(uncConfig.fillercolor).g}, ${this.hexToRgb(uncConfig.fillercolor).b}, 0.1);
            color: ${uncConfig.outlinecolor};
          ">
            ${uncConfig.text} ${this.renderExtraButtonIcon(uncConfig.icon)}
          </button>
        `
          : `
          <button class="crd-btn unc-btn expanded">
            UNC <i class="fas fa-code"></i>
          </button>
        `;

        return `
      <div class="btn-grid free-program-grid">
      ${uncButtonHTML}
        <button class="crd-btn info-btn expanded">
          <div class="text-container">
            <span class="text-switch visible" data-text="info">INFO</span>
            <span class="text-switch hidden" data-text="more">MORE</span>
          </div>
          <i class="fas fa-info-circle"></i>
        </button>
      </div>
      ${!hasExtraButtonWithSwap ? this.renderExtraButton(exploit) : ""}
      ${(() => {
        let displayDomain = websiteButtonText;
        if (exploit.href) {
          try {
            const url = new URL(exploit.href);
            displayDomain = url.hostname.replace(/^www\./, "");
          } catch (e) {
            displayDomain = exploit.href
              .replace(/^https?:\/\/(www\.)?/, "")
              .split("/")[0];
          }
        }
        return `<button class="crd-btn web-btn full-width">
          <div class="default-text">
            <i class="fas fa-external-link-alt"></i> ${websiteButtonText}
          </div>
          <div class="hover-text">
            <i class="fas fa-external-link-alt"></i> ${displayDomain}
          </div>
        </button>`;
      })()}
    `;
      }
    } else {
      // <CHANGE> Add premium class conditionally to price buttons
      const baseClasses = ["crd-btn", "prc-btn-new"];
      if (exploit.premium) {
        baseClasses.push("premium");
      }
      const finalPriceButtonClasses = baseClasses.join(" ");

      if (exploit.hideunc === true) {
        return `
      <div class="btn-grid">
      ${(() => {
        let displayDomain = websiteButtonText;
        if (exploit.href) {
          try {
            const url = new URL(exploit.href);
            displayDomain = url.hostname.replace(/^www\./, "");
          } catch (e) {
            displayDomain = exploit.href
              .replace(/^https?:\/\/(www\.)?/, "")
              .split("/")[0];
          }
        }
        return `<button class="crd-btn web-btn expanded">
          <div class="default-text">
            <i class="fas fa-external-link-alt"></i> ${websiteButtonText}
          </div>
          <div class="hover-text">
            <i class="fas fa-external-link-alt"></i> ${displayDomain}
          </div>
        </button>`;
      })()}
        <button class="crd-btn info-btn expanded">
          <div class="text-container">
            <span class="text-switch visible" data-text="info">INFO</span>
            <span class="text-switch hidden" data-text="more">MORE</span>
          </div>
          <i class="fas fa-info-circle"></i>
        </button>
      </div>
      ${this.renderExtraButton(exploit)}
      <button class="${finalPriceButtonClasses}">
        <div class="default-text">
          <i class="fas fa-tag"></i> BUY
        </div>
        <div class="price-text">
          <div class="text-container">
            <span class="text-switch visible" data-text="price"><i class="fas fa-tag"></i> ${exploit.price} ${exploit.period ? `<span class="prc-prd">${exploit.period}</span>` : ""}</span>
            <span class="text-switch hidden" data-text="logo"><img src="../assets/key-empire.png" alt="Key Empire" style="height: 1.2em; width: auto;"></span>
          </div>
        </div>
      </button>
    `;
      } else {
        const hasExtraButtonWithSwap =
          exploit.extrabutton &&
          exploit.extrabutton.enabled &&
          exploit.extrabutton.swap === true;
        const uncConfig = hasExtraButtonWithSwap ? exploit.extrabutton : null;

        const uncButtonHTML = hasExtraButtonWithSwap
          ? `
          <button class="crd-btn unc-btn" style="
            border: 1px solid ${uncConfig.outlinecolor};
            background-color: rgba(${this.hexToRgb(uncConfig.fillercolor).r}, ${this.hexToRgb(uncConfig.fillercolor).g}, ${this.hexToRgb(uncConfig.fillercolor).b}, 0.1);
            color: ${uncConfig.outlinecolor};
          ">
            ${uncConfig.text} ${this.renderExtraButtonIcon(uncConfig.icon)}
          </button>
        `
          : `
          <button class="crd-btn unc-btn">
            UNC <i class="fas fa-code"></i>
          </button>
        `;

        return `
      <div class="btn-grid">
      ${(() => {
        let displayDomain = websiteButtonText;
        if (exploit.href) {
          try {
            const url = new URL(exploit.href);
            displayDomain = url.hostname.replace(/^www\./, "");
          } catch (e) {
            displayDomain = exploit.href
              .replace(/^https?:\/\/(www\.)?/, "")
              .split("/")[0];
          }
        }
        return `<button class="crd-btn web-btn expanded">
          <div class="default-text">
            <i class="fas fa-external-link-alt"></i> ${websiteButtonText}
          </div>
          <div class="hover-text">
            <i class="fas fa-external-link-alt"></i> ${displayDomain}
          </div>
        </button>`;
      })()}
        ${uncButtonHTML}
        <button class="crd-btn info-btn expanded">
          <div class="text-container">
            <span class="text-switch visible" data-text="info">INFO</span>
            <span class="text-switch hidden" data-text="more">MORE</span>
          </div>
          <i class="fas fa-info-circle"></i>
        </button>
      </div>
      ${!hasExtraButtonWithSwap ? this.renderExtraButton(exploit) : ""}
      <button class="${finalPriceButtonClasses}">
        <div class="default-text">
          <i class="fas fa-tag"></i> BUY
        </div>
        <div class="price-text">
          <div class="text-container">
            <span class="text-switch visible" data-text="price"><i class="fas fa-tag"></i> ${exploit.price} ${exploit.period ? `<span class="prc-prd">${exploit.period}</span>` : ""}</span>
            <span class="text-switch hidden" data-text="logo"><img src="../assets/key-empire.png" alt="Key Empire" style="height: 1.2em; width: auto;"></span>
          </div>
        </div>
      </button>
    `;
      }
    }
  }

  static processSuncLinks(exploits) {
    return exploits.map((exploit) => {
      if (
        exploit.uncbuttonlink &&
        exploit.uncbuttonlink.includes("sunc.rubis.app")
      ) {
        try {
          const url = new URL(exploit.uncbuttonlink);
          const scrapParam = url.searchParams.get("scrap");
          const keyParam = url.searchParams.get("key");

          if (scrapParam && keyParam) {
            return {
              ...exploit,
              scrapId: scrapParam,
              key: keyParam,
              widget: true,
            };
          }
        } catch (error) {
          console.warn(
            `Failed to parse sunc URL for exploit ${exploit.id}:`,
            error,
          );
        }
      }

      return exploit;
    });
  }

  setupCardButtons() {
    const setupButtonHandlers = () => {
      document.querySelectorAll(".unc-btn").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true;
          button.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();

            const card =
              button.closest(".exp-crd") || button.closest(".exp-lst-itm");
            const exploit = this.findExploitByCardElement(card);

            if (exploit) {
              // Check if exploit has unclinks structure
              if (exploit.unclinks && typeof exploit.unclinks === "object") {
                const platforms = Object.keys(exploit.unclinks);

                // If only one platform, open directly without modal
                if (platforms.length === 1) {
                  const platform = platforms[0];
                  const link = exploit.unclinks[platform];

                  if (!link) {
                    // No link provided for single platform - show error
                    ModalManager.showNotification(
                      `No UNC link available for ${exploit.name}`,
                      "error",
                    );
                    return;
                  }

                  try {
                    const url = new URL(link);
                    const scrapParam = url.searchParams.get("scrap");
                    const keyParam = url.searchParams.get("key");

                    // Try to open as sUNC widget if parameters exist
                    if (scrapParam && keyParam) {
                      const suncExploit = {
                        ...exploit,
                        scrapId: scrapParam,
                        key: keyParam,
                        widget: true,
                        platform: platform,
                      };
                      ModalManager.openSuncWidget(suncExploit);
                      return;
                    }
                  } catch (error) {
                    console.warn(
                      `Failed to parse sunc URL for exploit ${exploit.id}:`,
                      error,
                    );
                  }

                  // Fallback: just open the link
                  window.open(link, "_blank");
                  return;
                }

                // Multiple platforms - show choice modal
                if (platforms.length > 1) {
                  ModalManager.openPlatformModal(exploit);
                  return;
                }
              }

              // <CHANGE> Fallback for old uncbuttonlink structure
              const uniquePlatforms = [...new Set(exploit.plat)];

              if (uniquePlatforms.length > 1) {
                ModalManager.openPlatformModal(exploit);
                return;
              }

              if (
                exploit.uncbuttonlink &&
                exploit.uncbuttonlink.includes("sunc.rubis.app")
              ) {
                try {
                  const url = new URL(exploit.uncbuttonlink);
                  const scrapParam = url.searchParams.get("scrap");
                  const keyParam = url.searchParams.get("key");

                  if (scrapParam && keyParam) {
                    const suncExploit = {
                      ...exploit,
                      scrapId: scrapParam,
                      key: keyParam,
                      widget: true,
                    };
                    ModalManager.openSuncWidget(suncExploit);
                    return;
                  }
                } catch (error) {
                  console.warn(
                    `Failed to parse sunc URL for exploit ${exploit.id}:`,
                    error,
                  );
                }
              }

              if (exploit.widget === true) {
                ModalManager.openSuncWidget(exploit);
              } else {
                if (exploit.uncbuttonlink && exploit.uncbuttonlink.length > 0) {
                  window.open(exploit.uncbuttonlink, "_blank");
                } else {
                  ModalManager.fetchUncDataForPlatform(
                    exploit,
                    uniquePlatforms[0],
                  );
                }
              }
            }
          };
        }
      });

      document.querySelectorAll(".info-btn").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true;
          button.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();

            const card =
              button.closest(".exp-crd") || button.closest(".exp-lst-itm");
            const exploit = this.findExploitByCardElement(card);

            if (exploit) {
              ModalManager.openInfoModal(exploit);
            }
          };
        }
      });

      document.querySelectorAll(".web-btn").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true;
          button.onclick = async (e) => {
            e.preventDefault();
            e.stopPropagation();

            const card =
              button.closest(".exp-crd") || button.closest(".exp-lst-itm");
            const exploit = this.findExploitByCardElement(card);

            if (exploit) {
              const statusCache = await fetchAllExploitStatuses();
              const exploitStatus = statusCache.get(exploit.id);

              const hasUnupdatedPlatform =
                exploitStatus &&
                Object.values(exploitStatus).some((status) => !status);

              if (hasUnupdatedPlatform && exploit.downtime) {
                exploit.downtime.enabled = true;
              } else if (exploit.downtime) {
                exploit.downtime.enabled = false;
              }

              ModalManager.checkAndQueueModals(exploit, "website");
            }
          };
        }
      });

      document.querySelectorAll(".prc-btn-new").forEach((button) => {
        if (!button._hasClickHandler) {
          button._hasClickHandler = true;
          button.onclick = async (e) => {
            e.preventDefault();
            e.stopPropagation();

            const card =
              button.closest(".exp-crd") || button.closest(".exp-lst-itm");
            const exploit = this.findExploitByCardElement(card);

            if (exploit) {
              const statusCache = await fetchAllExploitStatuses();
              const exploitStatus = statusCache.get(exploit.id);

              const hasUnupdatedPlatform =
                exploitStatus &&
                Object.values(exploitStatus).some((status) => !status);

              if (hasUnupdatedPlatform && exploit.downtime) {
                exploit.downtime.enabled = true;
              } else if (exploit.downtime) {
                exploit.downtime.enabled = false;
              }

              ModalManager.checkAndQueueModals(exploit, "price");
            }
          };
        }
      });
    };

    setupButtonHandlers();

    const observer = new MutationObserver((mutations) => {
      let shouldReSync = false;
      mutations.forEach((mutation) => {
        if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const node = mutation.addedNodes[i];
            if (
              node.nodeType === 1 &&
              (node.classList.contains("exp-crd") ||
                node.classList.contains("exp-lst-itm") ||
                node.querySelector(".exp-crd") ||
                node.querySelector(".exp-lst-itm"))
            ) {
              shouldReSync = true;
              break;
            }
          }
        }
      });

      if (shouldReSync) {
        setupButtonHandlers();
      }
    });

    observer.observe(document.body, { childList: true, subtree: true });

    document.head.insertAdjacentHTML(
      "beforeend",
      `
<style>
.crd-btn.expanded {
  flex: 1;
  min-width: 0;
}
.crd-btn.full-width {
  width: 100%;
}
</style>
`,
    );
  }

  findExploitByCardElement(element) {
    if (!element) return null;

    const dataName = element.getAttribute("data-name");
    if (dataName) {
      return expData.find((exp) => exp.name === dataName);
    }

    const nameElement =
      element.querySelector(".crd-ttl") ||
      element.querySelector(".lst-itm-ttl");
    if (nameElement) {
      const fullText = nameElement.textContent.trim();
      const cleanName = fullText
        .replace(/Verified|Premium|Warning|Updated|Down|Unknown|Untracked/g, "")
        .trim();

      let exploit = expData.find((exp) => exp.name === cleanName);

      if (!exploit) {
        exploit = expData.find((exp) => cleanName.startsWith(exp.name));
      }

      return exploit;
    }

    return null;
  }

  updateCounts() {
    const filteredCount = this.getElement("filteredCount");
    const totalCount = this.getElement("totalCount");

    if (filteredCount) {
      this.animateCounter(
        filteredCount,
        Number.parseInt(filteredCount.textContent) || 0,
        this.appState.filteredData.length,
      );
    }

    if (totalCount) {
      this.animateCounter(
        totalCount,
        Number.parseInt(totalCount.textContent) || 0,
        expData.length,
      );
    }
  }

  animateCounter(element, start, end) {
    if (!element || start === end) return;

    if (element._countAnimation) {
      cancelAnimationFrame(element._countAnimation);
    }

    const duration = 800;
    const startTime = performance.now();

    const updateCount = (timestamp) => {
      const elapsed = timestamp - startTime;
      const progress = Math.min(elapsed / duration, 1);

      const easeOutQuart = (x) => 1 - Math.pow(1 - x, 4);
      const easedProgress = easeOutQuart(progress);

      const currentCount = Math.floor(start + (end - start) * easedProgress);

      element.textContent = currentCount;

      if (progress < 1) {
        element._countAnimation = requestAnimationFrame(updateCount);
      } else {
        element.textContent = end;
        element._countAnimation = null;
      }
    };

    element._countAnimation = requestAnimationFrame(updateCount);
  }

  initTextSwitching() {
    const containers = document.querySelectorAll(
      ".info-btn .text-container, .price-info-btn .text-container, .more-info-btn .text-container, .prc-btn-new .price-text .text-container",
    );

    containers.forEach((container) => {
      const texts = container.querySelectorAll(".text-switch");

      container.style.position = "relative";
      container.style.display = "inline-flex";
      container.style.alignItems = "center";
      container.style.justifyContent = "center";
      container.style.minHeight = "20px";
      container.style.minWidth = "40px";

      texts.forEach((text) => {
        text.style.position = "absolute";
        text.style.top = "0";
        text.style.left = "0";
        text.style.width = "100%";
        text.style.height = "100%";
        text.style.display = "flex";
        text.style.alignItems = "center";
        text.style.justifyContent = "center";
        text.style.transition = "opacity 0.5s ease-in-out";
        text.style.opacity = text.classList.contains("visible") ? "1" : "0";
        text.style.pointerEvents = "none";
      });
    });

    const animationInterval = setInterval(() => {
      const currentContainers = document.querySelectorAll(
        ".info-btn .text-container, .price-info-btn .text-container, .more-info-btn .text-container, .prc-btn-new .price-text .text-container",
      );

      currentContainers.forEach((container) => {
        const visibleText = container.querySelector(".text-switch.visible");
        const hiddenText = container.querySelector(".text-switch.hidden");

        if (visibleText && hiddenText) {
          visibleText.style.opacity = "0";

          setTimeout(() => {
            visibleText.classList.remove("visible");
            visibleText.classList.add("hidden");
            hiddenText.classList.remove("hidden");
            hiddenText.classList.add("visible");
            hiddenText.offsetWidth;
            setTimeout(() => {
              hiddenText.style.opacity = "1";
            }, 50);
          }, 250);
        }
      });
    }, 3000);

    this.textSwitchingInterval = animationInterval;
  }

  updateScrollbarStyles() {
    const scrollableElements = [
      ".crd-cntnt",
      ".unc-modal-code",
      ".unc-modal-content",
      ".info-modal-content",
      ".info-modal-markdown",
      ".fltr-drwr-bdy",
    ];

    scrollableElements.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      elements.forEach((el) => {
        el.style.overflow = "hidden";
        void el.offsetHeight;
        el.style.overflow = "";
      });
    });
  }

  handleWindowResize() {
    const menu = this.getElement("menu");

    // Auto-close mobile menu on larger screens using CSS media query check
    if (window.matchMedia("(min-width: 769px)").matches && menu && !menu.classList.contains("hidden")) {
      menu.classList.add("hidden");
      document.body.classList.remove("menu-open");
    }

    if (this.appState.paginationManager) {
      this.appState.paginationManager.render();
    }
  }

  createModals() {
    ModalManager.createUncModal();
    ModalManager.createInfoModal();
    ModalManager.createWarningModal();
    ModalManager.createKeysystemModal();
    ModalManager.createDowntimeModal();
    ModalManager.createDetectedModal();
  }

  setupDropdowns() {
    const pageOverlay =
      document.getElementById("pageOverlay") || document.createElement("div");

    if (!document.getElementById("pageOverlay")) {
      pageOverlay.id = "pageOverlay";
      pageOverlay.className = "page-overlay";
      document.body.appendChild(pageOverlay);
    }

    const dropdowns = document.querySelectorAll(".custom-dropdown");

    dropdowns.forEach((dropdown) => {
      const selected = dropdown.querySelector(".custom-dropdown-selected");
      const options = dropdown.querySelector(".custom-dropdown-options");
      const optionItems = dropdown.querySelectorAll(".custom-dropdown-option");

      if (selected) {
        selected.addEventListener("click", (e) => {
          e.stopPropagation();

          dropdowns.forEach((d) => {
            if (d !== dropdown && d.classList.contains("active")) {
              d.classList.remove("active");
            }
          });

          dropdown.classList.toggle("active");

          if (dropdown.classList.contains("active")) {
            pageOverlay.classList.add("active");
          } else {
            pageOverlay.classList.remove("active");
          }
        });
      }

      if (optionItems) {
        optionItems.forEach((option) => {
          option.addEventListener("click", () => {
            const value = option.getAttribute("data-value");
            const text = option.textContent;

            if (selected && selected.querySelector("span")) {
              selected.querySelector("span").textContent = text;
            }

            optionItems.forEach((opt) => opt.classList.remove("selected"));
            option.classList.add("selected");

            dropdown.classList.remove("active");
            pageOverlay.classList.remove("active");

            if (
              dropdown.closest(".srt-fltr-cntr") ||
              dropdown.closest(".mob-srt-fltr-cntr")
            ) {
              this.appState.sortBy = value;
              this.updateExploits();
            }
          });
        });
      }
    });

    pageOverlay.addEventListener("click", () => {
      dropdowns.forEach((dropdown) => {
        dropdown.classList.remove("active");
      });

      pageOverlay.classList.remove("active");
    });
  }
}

class ModalManager {
  // Add modal queue system properties
  static modalQueue = [];
  static currentModalIndex = 0;
  static isProcessingQueue = false;

  // <CHANGE> Main function to check and queue all enabled modals
  static async checkAndQueueModals(exploit, buttonType = "website") {
    this.modalQueue = [];
    this.currentModalIndex = 0;

    // Check which modals are enabled and add them to queue in order
    if (exploit.warning && exploit.warning.enabled !== false) {
      this.modalQueue.push({ type: "warning", exploit, buttonType });
    }

    if (exploit.keysystem && exploit.keysystem.enabled !== false) {
      this.modalQueue.push({ type: "keysystem", exploit, buttonType });
    }

    if (exploit.downtime && exploit.downtime.enabled !== false) {
      this.modalQueue.push({ type: "downtime", exploit, buttonType });
    }

    if (exploit.detected && exploit.detected.enabled === true) {
      this.modalQueue.push({ type: "detected", exploit, buttonType });
    }

    // If no modals in queue, just open the link directly
    if (this.modalQueue.length === 0) {
      const targetUrl =
        buttonType === "price" ? exploit.priceHref : exploit.href;
      if (targetUrl) {
        window.open(targetUrl, "_blank");
      }
      return;
    }

    // Start showing modals from the queue
    this.isProcessingQueue = true;
    this.showNextModal();
  }

  // <CHANGE> Show the next modal in the queue
  static async showNextModal() {
    if (this.currentModalIndex >= this.modalQueue.length) {
      // All modals shown, open the final link
      this.isProcessingQueue = false;
      const lastModal = this.modalQueue[this.modalQueue.length - 1];
      const targetUrl =
        lastModal.buttonType === "price"
          ? lastModal.exploit.priceHref
          : lastModal.exploit.href;
      if (targetUrl) {
        window.open(targetUrl, "_blank");
      }
      return;
    }

    const modalData = this.modalQueue[this.currentModalIndex];

    // Show the appropriate modal based on type
    switch (modalData.type) {
      case "warning":
        this.showWarningModal(modalData.exploit, modalData.buttonType);
        break;
      case "keysystem":
        this.showKeysystemModal(modalData.exploit, modalData.buttonType);
        break;
      case "downtime":
        await this.showDowntimeModal(modalData.exploit, modalData.buttonType);
        break;
      case "detected":
        this.showDetectedModal(modalData.exploit, modalData.buttonType);
        break;
    }
  }

  static updateModalCounter(okayBtn, currentIndex, queueLength) {
    if (queueLength <= 1) return;

    let baseText = "Continue";
    if (currentIndex === queueLength - 1) {
      baseText = "Okay";
    }

    okayBtn.textContent = `${currentIndex + 1}/${queueLength} - ${baseText}`;
  }

  static proceedToNextModal() {
    this.currentModalIndex++;
    this.showNextModal();
  }

  static createUncModal() {
    const modalContainer = document.createElement("div");
    modalContainer.className = "unc-modal-container";
    modalContainer.id = "uncModalContainer";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
<div class="unc-modal-overlay" id="uncModalOverlay"></div>
<div class="unc-modal">
  <div class="unc-modal-header">
    <h2 class="unc-modal-title" id="uncModalTitle">UNC Code</h2>
  </div>
  <div class="unc-modal-content">
    <div class="unc-modal-info">
      <div class="unc-modal-exploit-info" id="uncModalExploitInfo">
        <div class="unc-modal-exploit-name" id="uncModalExploitName"></div>
        <div class="unc-modal-exploit-desc" id="uncModalExploitDesc"></div>
      </div>
    </div>
    <div class="unc-modal-code-container">
      <div class="unc-modal-code-header">
        <div class="unc-modal-code-title">UNC Code</div>
        <button class="unc-modal-copy-btn" id="uncModalCopyBtn">
          <i class="fas fa-copy"></i> Copy
        </button>
      </div>
      <pre class="unc-modal-code" id="uncModalCode"></pre>
    </div>
    <div class="unc-modal-loading" id="uncModalLoading">
      <div class="unc-modal-spinner"></div>
      <div class="unc-modal-loading-text">Loading UNC data...</div>
    </div>
    <div class="unc-modal-error" id="uncModalError">
      <i class="fas fa-exclamation-triangle"></i>
      <div class="unc-modal-error-text" id="uncModalErrorText">Failed to load UNC data</div>
    </div>
  </div>
  <div class="unc-modal-footer">
    <button class="unc-modal-btn unc-modal-btn-primary" id="uncModalCloseBtn">
      <i class="fas fa-times"></i> Close
    </button>
  </div>
</div>
`;

    document.body.appendChild(modalContainer);

    document
      .getElementById("uncModalOverlay")
      .addEventListener("click", ModalManager.closeUncModal);
    document
      .getElementById("uncModalCloseBtn")
      .addEventListener("click", ModalManager.closeUncModal);

    document.getElementById("uncModalCopyBtn").addEventListener("click", () => {
      const codeElement = document.getElementById("uncModalCode");

      if (codeElement) {
        navigator.clipboard.writeText(codeElement.textContent || "");

        const copyBtn = document.getElementById("uncModalCopyBtn");
        const originalText = copyBtn.innerHTML;

        copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';

        setTimeout(() => {
          copyBtn.innerHTML = originalText;
        }, 2000);
      }
    });
  }

  static openSuncWidget(exploit) {
    const modalId = `suncWidgetModalContainer_${exploit.id}`;
    let modalContainer = document.getElementById(modalId);

    if (!modalContainer) {
      ModalManager.createSuncWidgetModal(exploit.id);
      modalContainer = document.getElementById(modalId);
    }

    const widgetIframe = document.getElementById(
      `suncWidgetIframe_${exploit.id}`,
    );

    modalContainer.style.display = "flex";

    widgetIframe.src = "https://sunc.rubis.app/widget";
    widgetIframe.setAttribute("data-scrap-id", exploit.scrapId || "");
    widgetIframe.setAttribute("data-key", exploit.key || "");

    widgetIframe.onload = () => {
      if (exploit.scrapId && exploit.key) {
        ModalManager.postMessageToWidget(widgetIframe, {
          type: "sunc-widget:loadScrap",
          payload: {
            scrapId: exploit.scrapId,
            key: exploit.key,
          },
        });
      }
    };

    setTimeout(() => {
      document
        .querySelector(`#${modalId} .sunc-widget-modal`)
        .classList.add("show");
    }, 10);

    document.body.style.overflow = "hidden";
  }

  static closeSuncWidget(exploitId = null) {
    if (exploitId) {
      const modal = document.querySelector(
        `#suncWidgetModalContainer_${exploitId} .sunc-widget-modal`,
      );

      if (modal) {
        modal.classList.remove("show");

        setTimeout(() => {
          const container = document.getElementById(
            `suncWidgetModalContainer_${exploitId}`,
          );
          if (container) {
            container.style.display = "none";
          }

          const openWidgets = document.querySelectorAll(
            '.sunc-widget-modal-container[style*="flex"]',
          );
          if (openWidgets.length <= 1) {
            document.body.style.overflow = "";
          }
        }, 300);
      }
    } else {
      const modals = document.querySelectorAll(".sunc-widget-modal");

      modals.forEach((modal) => {
        modal.classList.remove("show");
      });

      setTimeout(() => {
        const containers = document.querySelectorAll(
          '[id^="suncWidgetModalContainer_"]',
        );
        containers.forEach((container) => {
          container.style.display = "none";
        });
        document.body.style.overflow = "";
      }, 300);
    }
  }

  static createSuncWidgetModal(exploitId) {
    const modalContainer = document.createElement("div");
    modalContainer.className = "sunc-widget-modal-container";
    modalContainer.id = `suncWidgetModalContainer_${exploitId}`;
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
  <div class="sunc-widget-modal-overlay" onclick="ModalManager.closeSuncWidget('${exploitId}')"></div>
  <div class="sunc-widget-modal">
    <button class="sunc-widget-close-btn" onclick="ModalManager.closeSuncWidget('${exploitId}')">
      <i class="fas fa-times"></i>
    </button>
    <iframe
      id="suncWidgetIframe_${exploitId}"
      class="sunc-widget-iframe-modal"
      frameborder="0">
    </iframe>
  </div>
  `;

    document.body.appendChild(modalContainer);
  }

  static createPlatformModal() {
    const modalContainer = document.createElement("div");
    modalContainer.className = "platform-modal-container";
    modalContainer.id = "platformModalContainer";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
      <div class="platform-modal-overlay"></div>
      <div class="platform-modal">
        <div class="platform-modal-header">
          <h2 class="platform-modal-title">Select Platform</h2>
          <p class="platform-modal-subtitle">Choose your platform to view the correct UNC</p>
        </div>
        <div class="platform-modal-content">
          <div id="platformOptions" class="platform-options"></div>
        </div>
        <div class="platform-modal-footer">
          <button id="platformModalCancel" class="platform-modal-btn platform-modal-btn-cancel">Cancel</button>
        </div>
      </div>
    `;

    document.body.appendChild(modalContainer);

    document
      .querySelector(".platform-modal-overlay")
      .addEventListener("click", ModalManager.closePlatformModal);
    document
      .getElementById("platformModalCancel")
      .addEventListener("click", ModalManager.closePlatformModal);
  }

  static openPlatformModal(exploit) {
    let modalContainer = document.getElementById("platformModalContainer");

    if (!modalContainer) {
      ModalManager.createPlatformModal();
      modalContainer = document.getElementById("platformModalContainer");
    }

    const platformOptions = document.getElementById("platformOptions");
    platformOptions.innerHTML = "";

    const uniquePlatforms = [...new Set(exploit.plat)];

    uniquePlatforms.forEach((platform) => {
      const platformButton = document.createElement("button");
      platformButton.className = "platform-option-btn";

      let iconHtml = "";
      let platformName = "";

      switch (platform) {
        case "windows":
          iconHtml = `<i class="fab fa-windows"></i>`;
          platformName = "Windows";
          break;
        case "macos":
          iconHtml = `<img src="/assets/macos.svg" alt="macOS" style="width:24px; height:24px;">`;
          platformName = "macOS";
          break;
        case "android":
          iconHtml = `<i class="fab fa-android"></i>`;
          platformName = "Android";
          break;
        case "ios":
          iconHtml = `<i class="fab fa-apple"></i>`;
          platformName = "iOS";
          break;
      }

      platformButton.innerHTML = `
      <div class="platform-option-icon">${iconHtml}</div>
      <div class="platform-option-name">${platformName}</div>
    `;

      platformButton.onclick = () => {
        ModalManager.closePlatformModal();
        ModalManager.fetchUncDataForPlatform(exploit, platform);
      };

      platformOptions.appendChild(platformButton);
    });

    modalContainer.style.display = "flex";

    setTimeout(() => {
      document.querySelector(".platform-modal").classList.add("show");
    }, 10);

    document.body.style.overflow = "hidden";
  }

  static closePlatformModal() {
    const modal = document.querySelector(".platform-modal");

    if (modal) {
      modal.classList.remove("show");

      setTimeout(() => {
        const container = document.getElementById("platformModalContainer");
        if (container) {
          container.style.display = "none";
        }
        document.body.style.overflow = "";
      }, 300);
    }
  }

  static async fetchUncDataForPlatform(exploit, platform) {
    const modalContainer = document.getElementById("uncModalContainer");

    if (!modalContainer) {
      ModalManager.createUncModal();
    }

    const modalContainer2 = document.getElementById("uncModalContainer");
    const modalTitle = document.getElementById("uncModalTitle");
    const modalExploitName = document.getElementById("uncModalExploitName");
    const modalExploitDesc = document.getElementById("uncModalExploitDesc");
    const modalCode = document.getElementById("uncModalCode");
    const modalLoading = document.getElementById("uncModalLoading");
    const modalError = document.getElementById("uncModalError");

    modalContainer2.style.display = "flex";
    modalTitle.textContent = `${exploit.name} UNC Code (${platform})`;
    modalExploitName.textContent = exploit.name;
    modalExploitDesc.textContent = exploit.desc;

    modalLoading.style.display = "flex";
    modalCode.style.display = "none";
    modalError.style.display = "none";

    try {
      const response = await fetch(
        `https://voxlis.net/assets/unc/${platform}/${exploit.id}.json`,
      );

      if (response.status === 404) {
        ModalManager.showNotification(
          `UNC/sUNC test for ${exploit.name} on ${platform} is unknown`,
          "error",
        );
        throw new Error("UNC data not found");
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const rawText = await response.text();

      modalLoading.style.display = "none";
      modalCode.style.display = "block";
      modalCode.textContent = rawText || "-- No UNC code available";

      if (window.hljs) {
        window.hljs.highlightElement(modalCode);
      }
    } catch (error) {
      modalLoading.style.display = "none";
      modalError.style.display = "flex";
      document.getElementById("uncModalErrorText").textContent =
        `Failed to load UNC data: ${error.message || "Unknown error"}`;
    }

    setTimeout(() => {
      document.querySelector(".unc-modal").classList.add("show");
    }, 10);

    document.body.style.overflow = "hidden";
  }

  static postMessageToWidget(iframe, message) {
    if (iframe && iframe.contentWindow) {
      iframe.contentWindow.postMessage(message, "https://sunc.rubis.app");
    }
  }

  static createInfoModal() {
    const modalContainer = document.getElementById("infoModalContainer");

    if (modalContainer) {
      document
        .getElementById("infoModalOverlay")
        .addEventListener("click", ModalManager.closeInfoModal);
      document
        .getElementById("infoModalCloseBtn")
        .addEventListener("click", ModalManager.closeInfoModal);

      const footerCloseBtn = document.getElementById("infoModalFooterCloseBtn");

      if (footerCloseBtn) {
        footerCloseBtn.addEventListener("click", ModalManager.closeInfoModal);
      }
    }
  }

  static openPlatformModal(exploit) {
    const modalContainer = document.getElementById("platformModal");

    if (!modalContainer) {
      console.error("Platform modal not found in HTML");
      return;
    }

    const platformOptions = document.getElementById("platformOptions");
    platformOptions.innerHTML = "";

    // Get platforms from unclinks object keys
    const platformsWithUnc =
      exploit.unclinks && typeof exploit.unclinks === "object"
        ? Object.keys(exploit.unclinks)
        : [];

    if (platformsWithUnc.length === 0) {
      console.warn("No UNC links found for exploit:", exploit.name);
      return;
    }

    platformsWithUnc.forEach((platform) => {
      const platformButton = document.createElement("button");
      platformButton.className = "platform-option-btn";

      let iconHtml = "";
      let platformName = "";

      switch (platform) {
        case "windows":
          iconHtml = `<i class="fab fa-windows"></i>`;
          platformName = "Windows";
          break;
        case "macos":
          iconHtml = `<img src="/assets/macos.svg" alt="macOS" style="width:24px; height:24px;">`;
          platformName = "macOS";
          break;
        case "android":
          iconHtml = `<i class="fab fa-android"></i>`;
          platformName = "Android";
          break;
        case "ios":
          iconHtml = `<i class="fab fa-apple"></i>`;
          platformName = "iOS";
          break;
      }

      platformButton.innerHTML = `
      <div class="platform-option-icon">${iconHtml}</div>
      <div class="platform-option-name">${platformName}</div>
    `;

      platformButton.onclick = () => {
        ModalManager.closePlatformModal();

        // Get the UNC link for this platform
        const uncLink = exploit.unclinks[platform];

        if (!uncLink) {
          ModalManager.showNotification(
            `No UNC link available for ${platformName}`,
            "error",
          );
          return;
        }

        // Check if it's a sUNC link
        try {
          const url = new URL(uncLink);
          const scrapParam = url.searchParams.get("scrap");
          const keyParam = url.searchParams.get("key");

          if (scrapParam && keyParam) {
            const suncExploit = {
              ...exploit,
              scrapId: scrapParam,
              key: keyParam,
              widget: true,
              platform: platform,
            };
            ModalManager.openSuncWidget(suncExploit);
            return;
          }
        } catch (error) {
          console.warn(
            `Failed to parse sunc URL for exploit ${exploit.id} on ${platform}:`,
            error,
          );
        }

        // Fallback: try to fetch UNC data or open link
        if (uncLink.startsWith("http://") || uncLink.startsWith("https://")) {
          window.open(uncLink, "_blank");
        } else {
          ModalManager.fetchUncDataForPlatform(exploit, platform);
        }
      };

      platformOptions.appendChild(platformButton);
    });

    modalContainer.style.display = "flex";

    setTimeout(() => {
      document.querySelector(".platform-modal").classList.add("show");
    }, 10);

    document.body.style.overflow = "hidden";

    const overlay = modalContainer.querySelector(".platform-modal-overlay");
    const cancelBtn = document.getElementById("platformModalCancel");

    overlay.onclick = () => ModalManager.closePlatformModal();
    cancelBtn.onclick = () => ModalManager.closePlatformModal();
  }

  static closePlatformModal() {
    const modal = document.querySelector(".platform-modal");

    if (modal) {
      modal.classList.remove("show");

      setTimeout(() => {
        const container = document.getElementById("platformModal");
        if (container) {
          container.style.display = "none";
        }
        document.body.style.overflow = "";
      }, 300);
    }
  }

  static async fetchUncDataForPlatform(exploit, platform) {
    const modalContainer = document.getElementById("uncModalContainer");

    if (!modalContainer) {
      ModalManager.createUncModal();
    }

    const modalContainer2 = document.getElementById("uncModalContainer");
    const modalTitle = document.getElementById("uncModalTitle");
    const modalExploitName = document.getElementById("uncModalExploitName");
    const modalExploitDesc = document.getElementById("uncModalExploitDesc");
    const modalCode = document.getElementById("uncModalCode");
    const modalLoading = document.getElementById("uncModalLoading");
    const modalError = document.getElementById("uncModalError");

    modalContainer2.style.display = "flex";
    modalTitle.textContent = `${exploit.name} UNC Code (${platform.charAt(0).toUpperCase() + platform.slice(1)})`;
    modalExploitName.textContent = exploit.name;
    modalExploitDesc.textContent = exploit.desc;

    modalLoading.style.display = "flex";
    modalCode.style.display = "none";
    modalError.style.display = "none";

    try {
      const response = await fetch(
        `https://voxlis.net/assets/unc/${platform}/${exploit.id}.json`,
      );

      if (response.status === 404) {
        ModalManager.showNotification(
          `UNC/sUNC test for ${exploit.name} on ${platform} is unknown`,
          "error",
        );
        throw new Error("UNC data not found");
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const rawText = await response.text();

      modalLoading.style.display = "none";
      modalCode.style.display = "block";
      modalCode.textContent = rawText || "-- No UNC code available";

      if (window.hljs) {
        window.hljs.highlightElement(modalCode);
      }
    } catch (error) {
      modalLoading.style.display = "none";
      modalError.style.display = "flex";
      document.getElementById("uncModalErrorText").textContent =
        `Failed to load UNC data: ${error.message || "Unknown error"}`;
    }

    setTimeout(() => {
      document.querySelector(".unc-modal").classList.add("show");
    }, 10);

    document.body.style.overflow = "hidden";
  }

  // ============ WARNING MODAL ============
  static createWarningModal() {
    const modalContainer = document.createElement("div");
    modalContainer.id = "warningModal";
    modalContainer.className = "warning-modal-container";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
<div class="warning-modal-overlay"></div>
<div class="warning-modal">
  <div class="warning-modal-header">
    <img id="warningModalIcon" class="warning-modal-icon-img" src="/placeholder.svg" alt="Warning Icon" style="width: 32px; height: 32px; margin-right: 10px; object-fit: contain;">
    <h2 id="warningModalTitle" class="warning-modal-title">Information</h2>
  </div>
  <div class="warning-modal-content">
    <div id="warningModalVideo" class="warning-modal-video" style="display:none; width: 100%; max-width: 100%; margin-bottom: 15px;">
      <iframe id="warningModalVideoFrame" width="100%" height="225" src="/placeholder.svg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="border-radius: 8px;"></iframe>
    </div>
    <p id="warningModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
  </div>
  <div class="warning-modal-footer">
    <button id="warningModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
    <button id="warningModalOkay" class="warning-modal-btn warning-modal-btn-okay">Okay</button>
  </div>
</div>
`;

    document.body.appendChild(modalContainer);
  }

  // ============ KEYSYSTEM MODAL ============
  static createKeysystemModal() {
    const modalContainer = document.createElement("div");
    modalContainer.id = "keysystemModal";
    modalContainer.className = "warning-modal-container";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
<div class="warning-modal-overlay"></div>
<div class="warning-modal">
  <div class="warning-modal-header">
    <img id="keysystemModalIcon" class="warning-modal-icon-img" src="/placeholder.svg" alt="Keysystem Icon" style="width: 32px; height: 32px; margin-right: 10px; object-fit: contain;">
    <h2 id="keysystemModalTitle" class="warning-modal-title">Information</h2>
  </div>
  <div class="warning-modal-content">
    <div id="keysystemModalVideo" class="warning-modal-video" style="display:none; width: 100%; max-width: 100%; margin-bottom: 15px;">
      <iframe id="keysystemModalVideoFrame" width="100%" height="225" src="/placeholder.svg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="border-radius: 8px;"></iframe>
    </div>
    <p id="keysystemModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
  </div>
  <div class="warning-modal-footer">
    <button id="keysystemModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
    <button id="keysystemModalOkay" class="warning-modal-btn warning-modal-btn-okay">Okay</button>
  </div>
</div>
`;

    document.body.appendChild(modalContainer);
  }

  // ============ DOWNTIME MODAL ============
  static createDowntimeModal() {
    const modalContainer = document.createElement("div");
    modalContainer.id = "downtimeModal";
    modalContainer.className = "warning-modal-container";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
<div class="warning-modal-overlay"></div>
<div class="warning-modal">
  <div class="warning-modal-header">
    <img id="downtimeModalIcon" class="warning-modal-icon-img" src="/placeholder.svg" alt="Downtime Icon" style="width: 32px; height: 32px; margin-right: 10px; object-fit: contain;">
    <h2 id="downtimeModalTitle" class="warning-modal-title">Information</h2>
  </div>
  <div class="warning-modal-content">
    <div id="downtimeModalVideo" class="warning-modal-video" style="display:none; width: 100%; max-width: 100%; margin-bottom: 15px;">
      <iframe id="downtimeModalVideoFrame" width="100%" height="225" src="/placeholder.svg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="border-radius: 8px;"></iframe>
    </div>
    <p id="downtimeModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
  </div>
  <div class="warning-modal-footer">
    <button id="downtimeModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
    <button id="downtimeModalOkay" class="warning-modal-btn warning-modal-btn-okay">Okay</button>
  </div>
</div>
`;

    document.body.appendChild(modalContainer);
  }

  static createDetectedModal() {
    const modalContainer = document.createElement("div");
    modalContainer.id = "detectedModal";
    modalContainer.className = "warning-modal-container";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
<div class="warning-modal-overlay"></div>
<div class="warning-modal">
  <div class="warning-modal-header">
    <img id="detectedModalIcon" class="warning-modal-icon-img" src="/placeholder.svg" alt="Detected Icon" style="width: 32px; height: 32px; margin-right: 10px; object-fit: contain;">
    <h2 id="detectedModalTitle" class="warning-modal-title">Information</h2>
  </div>
  <div class="warning-modal-content">
    <div id="detectedModalVideo" class="warning-modal-video" style="display:none; width: 100%; max-width: 100%; margin-bottom: 15px;">
      <iframe id="detectedModalVideoFrame" width="100%" height="225" src="/placeholder.svg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="border-radius: 8px;"></iframe>
    </div>
    <p id="detectedModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
  </div>
  <div class="warning-modal-footer">
    <button id="detectedModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
    <button id="detectedModalOkay" class="warning-modal-btn warning-modal-btn-okay">Okay</button>
  </div>
</div>
`;

    document.body.appendChild(modalContainer);
  }

  // <CHANGE> Simplified - only called when multiple platforms exist
  static openUncChoiceModal(exploit, singlePlatform = null) {
    let modalContainer = document.getElementById("platformModal");

    if (!modalContainer) {
      console.error("Platform modal not found in HTML");
      return;
    }

    modalContainer._currentExploit = exploit;
    modalContainer._singlePlatform = singlePlatform;

    const choiceButtonsDiv = modalContainer.querySelector(
      ".platform-choice-buttons",
    );
    const platformOptionsDiv = document.getElementById("platformOptions");

    choiceButtonsDiv.style.display = "grid";
    platformOptionsDiv.style.display = "none";
    platformOptionsDiv.classList.remove("show");

    const viewUncBtn = document.getElementById("viewUncBtn");
    const viewSuncBtn = document.getElementById("viewSuncBtn");

    viewUncBtn.onclick = () => {
      ModalManager.showPlatformSelectionForUNC(exploit);
    };

    viewSuncBtn.onclick = () => {
      ModalManager.showPlatformSelectionForSunc(exploit);
    };

    modalContainer.style.display = "flex";

    setTimeout(() => {
      document.querySelector(".platform-modal").classList.add("show");
    }, 10);

    document.body.style.overflow = "hidden";

    const overlay = modalContainer.querySelector(".platform-modal-overlay");
    const cancelBtn = document.getElementById("platformModalCancel");

    overlay.onclick = () => ModalManager.closePlatformModal();
    cancelBtn.onclick = () => ModalManager.closePlatformModal();
  }

  static showPlatformSelectionForUNC(exploit) {
    const platformOptionsDiv = document.getElementById("platformOptions");
    const choiceButtonsDiv = document.querySelector(".platform-choice-buttons");

    platformOptionsDiv.innerHTML = "";
    choiceButtonsDiv.style.display = "none";

    const platforms = Object.keys(exploit.unclinks);

    platforms.forEach((platform) => {
      const platformButton = document.createElement("button");
      platformButton.className = "platform-option-btn";

      let iconHtml = "";
      let platformName = "";

      switch (platform) {
        case "windows":
          iconHtml = `<i class="fab fa-windows"></i>`;
          platformName = "Windows";
          break;
        case "macos":
          iconHtml = `<img src="/assets/macos.svg" alt="macOS" style="width:24px; height:24px;">`;
          platformName = "macOS";
          break;
        case "android":
          iconHtml = `<i class="fab fa-android"></i>`;
          platformName = "Android";
          break;
        case "ios":
          iconHtml = `<i class="fab fa-apple"></i>`;
          platformName = "iOS";
          break;
      }

      platformButton.innerHTML = `
      <div class="platform-option-icon">${iconHtml}</div>
      <div class="platform-option-name">${platformName}</div>
    `;

      platformButton.onclick = () => {
        ModalManager.openRegularUNC(exploit, platform);
      };

      platformOptionsDiv.appendChild(platformButton);
    });

    platformOptionsDiv.style.display = "grid";
    platformOptionsDiv.classList.add("show");
  }

  static showPlatformSelectionForSunc(exploit) {
    const platformOptionsDiv = document.getElementById("platformOptions");
    const choiceButtonsDiv = document.querySelector(".platform-choice-buttons");

    platformOptionsDiv.innerHTML = "";
    choiceButtonsDiv.style.display = "none";

    const platforms = Object.keys(exploit.unclinks);

    platforms.forEach((platform) => {
      const platformButton = document.createElement("button");
      platformButton.className = "platform-option-btn";

      let iconHtml = "";
      let platformName = "";

      switch (platform) {
        case "windows":
          iconHtml = `<i class="fab fa-windows"></i>`;
          platformName = "Windows";
          break;
        case "macos":
          iconHtml = `<img src="/assets/macos.svg" alt="macOS" style="width:24px; height:24px;">`;
          platformName = "macOS";
          break;
        case "android":
          iconHtml = `<i class="fab fa-android"></i>`;
          platformName = "Android";
          break;
        case "ios":
          iconHtml = `<i class="fab fa-apple"></i>`;
          platformName = "iOS";
          break;
      }

      platformButton.innerHTML = `
      <div class="platform-option-icon">${iconHtml}</div>
      <div class="platform-option-name">${platformName}</div>
    `;

      platformButton.onclick = () => {
        ModalManager.openSuncForPlatform(exploit, platform);
      };

      platformOptionsDiv.appendChild(platformButton);
    });

    platformOptionsDiv.style.display = "grid";
    platformOptionsDiv.classList.add("show");
  }

  static openRegularUNC(exploit, platform) {
    ModalManager.closePlatformModal();

    if (exploit.unclinks && exploit.unclinks[platform]) {
      const link = exploit.unclinks[platform];

      try {
        window.open(link, "_blank");
      } catch (error) {
        console.error(`Failed to open UNC link for ${platform}:`, error);
        ModalManager.openUncModal(exploit);
      }
    } else {
      ModalManager.openUncModal(exploit);
    }
  }

  static openSuncForPlatform(exploit, platform) {
    if (exploit.unclinks && exploit.unclinks[platform]) {
      const link = exploit.unclinks[platform];

      try {
        const url = new URL(link);
        const scrapParam = url.searchParams.get("scrap");
        const keyParam = url.searchParams.get("key");

        if (scrapParam && keyParam) {
          const suncExploit = {
            ...exploit,
            scrapId: scrapParam,
            key: keyParam,
            widget: true,
            platform: platform,
          };
          ModalManager.openSuncWidget(suncExploit);
          return;
        }
      } catch (error) {
        console.warn(`Failed to parse sunc URL for ${platform}:`, error);
      }

      ModalManager.showErrorNotification(
        `Oops! we dont have the sUNC link for this ${exploit.name} ${platform} help us get it!`,
      );
    } else {
      ModalManager.showErrorNotification(
        `Oops! we dont have the sUNC link for this ${exploit.name} ${platform} help us get it!`,
      );
    }
  }

  static openUncModal(exploit) {
    const modalContainer = document.getElementById("uncModalContainer");

    if (!modalContainer) {
      ModalManager.createUncModal();
    }

    const modalContainer2 = document.getElementById("uncModalContainer");
    const modalTitle = document.getElementById("uncModalTitle");
    const modalExploitName = document.getElementById("uncModalExploitName");
    const modalExploitDesc = document.getElementById("uncModalExploitDesc");
    const modalCode = document.getElementById("uncModalCode");
    const modalLoading = document.getElementById("uncModalLoading");
    const modalError = document.getElementById("uncModalError");

    modalContainer2.style.display = "flex";
    modalTitle.textContent = `${exploit.name} UNC Code`;
    modalExploitName.textContent = exploit.name;
    modalExploitDesc.textContent = exploit.desc;

    modalLoading.style.display = "flex";
    modalCode.style.display = "none";
    modalError.style.display = "none";

    ModalManager.fetchUncData(exploit.id, exploit.name)
      .then((data) => {
        modalLoading.style.display = "none";
        modalCode.style.display = "block";
        modalCode.textContent = data.code || "-- No UNC code available";

        if (window.hljs) {
          window.hljs.highlightElement(modalCode);
        }
      })
      .catch((error) => {
        modalLoading.style.display = "none";
        modalError.style.display = "flex";
        document.getElementById("uncModalErrorText").textContent =
          `Failed to load UNC data: ${error.message || "Unknown error"}`;
      });

    setTimeout(() => {
      document.querySelector(".unc-modal").classList.add("show");
    }, 10);

    document.body.style.overflow = "hidden";
  }

  static closeUncModal() {
    const modal = document.querySelector(".unc-modal");

    if (modal) {
      modal.classList.remove("show");

      setTimeout(() => {
        const container = document.getElementById("uncModalContainer");

        if (container) {
          container.style.display = "none";
        }

        document.body.style.overflow = "";
      }, 300);
    }
  }

  static createKeysystemModal() {
    const modalContainer = document.createElement("div");
    modalContainer.id = "keysystemModal";
    modalContainer.className = "warning-modal-container";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
<div class="warning-modal-overlay"></div>
<div class="warning-modal">
  <div class="warning-modal-header">
    <img id="keysystemModalIcon" class="warning-modal-icon-img" src="/placeholder.svg" alt="Keysystem Icon" style="width: 32px; height: 32px; margin-right: 10px; object-fit: contain;">
    <h2 id="keysystemModalTitle" class="warning-modal-title">Information</h2>
  </div>
  <div class="warning-modal-content">
    <p id="keysystemModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
    <div id="keysystemModalVideo" class="warning-modal-video" style="display:none; margin-top: 15px; width: 100%; max-width: 400px;">
      <iframe id="keysystemModalVideoFrame" width="100%" height="225" src="/placeholder.svg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="border-radius: 8px;"></iframe>
    </div>
  </div>
  <div class="warning-modal-footer">
    <button id="keysystemModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
    <button id="keysystemModalOkay" class="warning-modal-btn warning-modal-btn-okay">Continue</button>
  </div>
</div>
`;

    document.body.appendChild(modalContainer);
  }

  static openInfoModal(exploit) {
    const modalContainer = document.getElementById("infoModalContainer");
    const modalTitle = document.getElementById("infoModalTitle");
    const modalExploitName = document.getElementById("infoModalExploitName");
    const modalExploitDesc = document.getElementById("infoModalExploitDesc");
    const modalMarkdown = document.getElementById("infoModalMarkdown");

    modalContainer.style.display = "flex";
    modalTitle.textContent = `${exploit.name} Information`;
    modalExploitName.textContent = exploit.name;
    modalExploitDesc.textContent = exploit.desc;

    if (exploit.info) {
      const marked = window.marked;
      modalMarkdown.innerHTML = marked.parse(exploit.info);

      if (window.hljs) {
        document
          .querySelectorAll("#infoModalMarkdown pre code")
          .forEach((block) => {
            window.hljs.highlightElement(block);
          });
      }
    } else {
      modalMarkdown.innerHTML =
        "<p>No additional information available for this exploit.</p>";
    }

    setTimeout(() => {
      document.querySelector(".info-modal").classList.add("show");
    }, 10);

    document.body.style.overflow = "hidden";
  }

  static closeInfoModal() {
    const modal = document.querySelector(".info-modal");

    if (modal) {
      modal.classList.remove("show");

      setTimeout(() => {
        const container = document.getElementById("infoModalContainer");

        if (container) {
          container.style.display = "none";
        }

        document.body.style.overflow = "";
      }, 300);
    }
  }

  static createDowntimeModal() {
    const modalContainer = document.createElement("div");
    modalContainer.id = "downtimeModal";
    modalContainer.className = "warning-modal-container";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
<div class="warning-modal-overlay"></div>
<div class="warning-modal">
  <div class="warning-modal-header">
    <img id="downtimeModalIcon" class="warning-modal-icon-img" src="/placeholder.svg" alt="Downtime Icon" style="width: 32px; height: 32px; margin-right: 10px; object-fit: contain;">
    <h2 id="downtimeModalTitle" class="warning-modal-title">Information</h2>
  </div>
  <div class="warning-modal-content">
    <p id="downtimeModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
    <div id="downtimeModalVideo" class="warning-modal-video" style="display:none; margin-top: 15px; width: 100%; max-width: 400px;">
      <iframe id="downtimeModalVideoFrame" width="100%" height="225" src="/placeholder.svg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="border-radius: 8px;"></iframe>
    </div>
  </div>
  <div class="warning-modal-footer">
    <button id="downtimeModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
    <button id="downtimeModalOkay" class="warning-modal-btn warning-modal-btn-okay">Continue</button>
  </div>
</div>
`;

    document.body.appendChild(modalContainer);
  }

  static showWarningModal(exploit, buttonType = "website") {
    const warningModal = document.getElementById("warningModal");
    const warningData = exploit.warning;

    const warningText = document.getElementById("warningModalText");
    const warningTitle = document.getElementById("warningModalTitle");
    const warningIcon = document.getElementById("warningModalIcon");
    const warningVideo = document.getElementById("warningModalVideo");
    const warningVideoFrame = document.getElementById("warningModalVideoFrame");
    const cancelBtn = document.getElementById("warningModalCancel");
    const okayBtn = document.getElementById("warningModalOkay");

    if (warningData?.title) {
      warningTitle.textContent = warningData.title;
    } else {
      warningTitle.textContent = "Warning";
    }

    if (warningData?.icon) {
      warningIcon.src = warningData.icon;
      warningIcon.style.display = "inline-block";
    } else {
      warningIcon.style.display = "none";
    }

    if (warningData?.video) {
      let videoUrl = warningData.video;

      if (videoUrl.includes("youtube.com") || videoUrl.includes("youtu.be")) {
        if (videoUrl.includes("watch?v=")) {
          const videoId = videoUrl.split("watch?v=")[1].split("&")[0];
          videoUrl = `https://www.youtube.com/embed/${videoId}`;
        } else if (videoUrl.includes("youtu.be/")) {
          const videoId = videoUrl.split("youtu.be/")[1].split("?")[0];
          videoUrl = `https://www.youtube.com/embed/${videoId}`;
        } else if (videoUrl.includes("/channel/")) {
          const channelId = videoUrl
            .split("/channel/")[1]
            .split("?")[0]
            .split("/")[0];
          videoUrl = `https://www.youtube.com/embed/videoseries?list=UU${channelId.substring(2)}`;
        } else if (videoUrl.includes("you.tube")) {
          videoUrl = videoUrl.replace("you.tube", "www.youtube.com");
          if (videoUrl.includes("/channel/")) {
            const channelId = videoUrl
              .split("/channel/")[1]
              .split("?")[0]
              .split("/")[0];
            videoUrl = `https://www.youtube.com/embed/videoseries?list=UU${channelId.substring(2)}`;
          }
        }
      }

      warningVideoFrame.src = videoUrl;
      warningVideo.style.display = "block";
    } else {
      warningVideo.style.display = "none";
      warningVideoFrame.src = "";
    }

    let targetUrl;
    if (warningData?.continue === "href") {
      targetUrl = exploit.href;
    } else if (warningData?.continue === "priceHref") {
      targetUrl = exploit.priceHref;
    } else {
      targetUrl = buttonType === "price" ? exploit.priceHref : exploit.href;
    }

    warningText.textContent =
      warningData?.desc ||
      exploit.warningInfo ||
      "Are you sure you want to visit this website?";

    warningModal.style.display = "flex";
    document.body.style.overflow = "hidden";
    warningModal.classList.add("active");

    if (this.isProcessingQueue) {
      this.updateModalCounter(
        okayBtn,
        this.currentModalIndex,
        this.modalQueue.length,
      );
    } else {
      okayBtn.textContent = "Okay";
    }

    const cleanup = () => {
      if (warningVideoFrame) {
        warningVideoFrame.src = "";
      }

      warningModal.classList.remove("active");
      setTimeout(() => {
        warningModal.style.display = "none";
        document.body.style.overflow = "";
      }, 300);
    };

    cancelBtn.onclick = () => {
      cleanup();
      if (this.isProcessingQueue) {
        this.modalQueue = [];
        this.currentModalIndex = 0;
        this.isProcessingQueue = false;
      }
    };

    okayBtn.onclick = () => {
      cleanup();
      setTimeout(() => {
        if (this.isProcessingQueue) {
          this.proceedToNextModal();
        } else {
          if (targetUrl) {
            window.open(targetUrl, "_blank");
          }
        }
      }, 300);
    };

    const overlay = warningModal.querySelector(".warning-modal-overlay");
    if (overlay) {
      overlay.onclick = () => {
        cleanup();
        if (this.isProcessingQueue) {
          this.modalQueue = [];
          this.currentModalIndex = 0;
          this.isProcessingQueue = false;
        }
      };
    }
  }

  static createDetectedModal() {
    const modalContainer = document.createElement("div");
    modalContainer.id = "detectedModal";
    modalContainer.className = "warning-modal-container";
    modalContainer.style.display = "none";

    modalContainer.innerHTML = `
<div class="warning-modal-overlay"></div>
<div class="warning-modal">
  <div class="warning-modal-header">
    <img id="detectedModalIcon" class="warning-modal-icon-img" src="/placeholder.svg" alt="Detected Icon" style="width: 32px; height: 32px; margin-right: 10px; object-fit: contain;">
    <h2 id="detectedModalTitle" class="warning-modal-title">Information</h2>
  </div>
  <div class="warning-modal-content">
    <p id="detectedModalText" class="warning-modal-text">Are you sure you want to visit this website?</p>
    <div id="detectedModalVideo" class="warning-modal-video" style="display:none; margin-top: 15px; width: 100%; max-width: 400px;">
      <iframe id="detectedModalVideoFrame" width="100%" height="225" src="/placeholder.svg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="border-radius: 8px;"></iframe>
    </div>
  </div>
  <div class="warning-modal-footer">
    <button id="detectedModalCancel" class="warning-modal-btn warning-modal-btn-cancel">Cancel</button>
    <button id="detectedModalOkay" class="warning-modal-btn warning-modal-btn-okay">Continue</button>
  </div>
</div>
`;

    document.body.appendChild(modalContainer);
  }

  static showDetectedModal(exploit, buttonType = "website") {
    const detectedModal = document.getElementById("detectedModal");
    const detectedData = exploit.detected;

    const detectedText = document.getElementById("detectedModalText");
    const detectedTitle = document.getElementById("detectedModalTitle");
    const detectedIcon = document.getElementById("detectedModalIcon");
    const detectedVideo = document.getElementById("detectedModalVideo");
    const detectedVideoFrame = document.getElementById(
      "detectedModalVideoFrame",
    );
    const cancelBtn = document.getElementById("detectedModalCancel");
    const okayBtn = document.getElementById("detectedModalOkay");

    if (detectedData?.title) {
      detectedTitle.textContent = detectedData.title;
    } else {
      detectedTitle.textContent = "Warning";
    }

    if (detectedData?.icon) {
      detectedIcon.src = detectedData.icon;
      detectedIcon.style.display = "inline-block";
    } else {
      detectedIcon.style.display = "none";
    }

    if (detectedData?.video) {
      let videoUrl = detectedData.video;

      if (videoUrl.includes("youtube.com") || videoUrl.includes("youtu.be")) {
        if (videoUrl.includes("watch?v=")) {
          const videoId = videoUrl.split("watch?v=")[1].split("&")[0];
          videoUrl = `https://www.youtube.com/embed/${videoId}`;
        } else if (videoUrl.includes("youtu.be/")) {
          const videoId = videoUrl.split("youtu.be/")[1].split("?")[0];
          videoUrl = `https://www.youtube.com/embed/${videoId}`;
        } else if (videoUrl.includes("/channel/")) {
          const channelId = videoUrl
            .split("/channel/")[1]
            .split("?")[0]
            .split("/")[0];
          videoUrl = `https://www.youtube.com/embed/videoseries?list=UU${channelId.substring(2)}`;
        } else if (videoUrl.includes("you.tube")) {
          videoUrl = videoUrl.replace("you.tube", "www.youtube.com");
          if (videoUrl.includes("/channel/")) {
            const channelId = videoUrl
              .split("/channel/")[1]
              .split("?")[0]
              .split("/")[0];
            videoUrl = `https://www.youtube.com/embed/videoseries?list=UU${channelId.substring(2)}`;
          }
        }
      }

      detectedVideoFrame.src = videoUrl;
      detectedVideo.style.display = "block";
    } else {
      detectedVideo.style.display = "none";
      detectedVideoFrame.src = "";
    }

    let targetUrl;
    if (detectedData?.continue === "href") {
      targetUrl = exploit.href;
    } else if (detectedData?.continue === "priceHref") {
      targetUrl = exploit.priceHref;
    } else {
      targetUrl = buttonType === "price" ? exploit.priceHref : exploit.href;
    }

    detectedText.textContent =
      detectedData?.desc || "Are you sure you want to visit this website?";

    detectedModal.style.display = "flex";
    document.body.style.overflow = "hidden";
    detectedModal.classList.add("active");

    if (this.isProcessingQueue) {
      this.updateModalCounter(
        okayBtn,
        this.currentModalIndex,
        this.modalQueue.length,
      );
    } else {
      okayBtn.textContent = "Okay";
    }

    const cleanup = () => {
      if (detectedVideoFrame) {
        detectedVideoFrame.src = "";
      }

      detectedModal.classList.remove("active");
      setTimeout(() => {
        detectedModal.style.display = "none";
        document.body.style.overflow = "";
      }, 300);
    };

    cancelBtn.onclick = () => {
      cleanup();
      if (this.isProcessingQueue) {
        this.modalQueue = [];
        this.currentModalIndex = 0;
        this.isProcessingQueue = false;
      }
    };

    okayBtn.onclick = () => {
      cleanup();
      setTimeout(() => {
        if (this.isProcessingQueue) {
          this.proceedToNextModal();
        } else {
          if (targetUrl) {
            window.open(targetUrl, "_blank");
          }
        }
      }, 300);
    };

    const overlay = detectedModal.querySelector(".warning-modal-overlay");
    if (overlay) {
      overlay.onclick = () => {
        cleanup();
        if (this.isProcessingQueue) {
          this.modalQueue = [];
          this.currentModalIndex = 0;
          this.isProcessingQueue = false;
        }
      };
    }
  }

  static showKeysystemModal(exploit, buttonType = "website") {
    const keysystemModal = document.getElementById("keysystemModal");
    const keysystemData = exploit.keysystem;

    const keysystemText = document.getElementById("keysystemModalText");
    const keysystemTitle = document.getElementById("keysystemModalTitle");
    const keysystemIcon = document.getElementById("keysystemModalIcon");
    const keysystemVideo = document.getElementById("keysystemModalVideo");
    const keysystemVideoFrame = document.getElementById(
      "keysystemModalVideoFrame",
    );
    const cancelBtn = document.getElementById("keysystemModalCancel");
    const okayBtn = document.getElementById("keysystemModalOkay");

    if (keysystemData?.title) {
      keysystemTitle.textContent = keysystemData.title;
    } else {
      keysystemTitle.textContent = "Warning";
    }

    if (keysystemData?.icon) {
      keysystemIcon.src = keysystemData.icon;
      keysystemIcon.style.display = "inline-block";
    } else {
      keysystemIcon.style.display = "none";
    }

    if (keysystemData?.video) {
      let videoUrl = keysystemData.video;

      if (videoUrl.includes("youtube.com") || videoUrl.includes("youtu.be")) {
        if (videoUrl.includes("watch?v=")) {
          const videoId = videoUrl.split("watch?v=")[1].split("&")[0];
          videoUrl = `https://www.youtube.com/embed/${videoId}`;
        } else if (videoUrl.includes("youtu.be/")) {
          const videoId = videoUrl.split("youtu.be/")[1].split("?")[0];
          videoUrl = `https://www.youtube.com/embed/${videoId}`;
        } else if (videoUrl.includes("/channel/")) {
          const channelId = videoUrl
            .split("/channel/")[1]
            .split("?")[0]
            .split("/")[0];
          videoUrl = `https://www.youtube.com/embed/videoseries?list=UU${channelId.substring(2)}`;
        } else if (videoUrl.includes("you.tube")) {
          videoUrl = videoUrl.replace("you.tube", "www.youtube.com");
          if (videoUrl.includes("/channel/")) {
            const channelId = videoUrl
              .split("/channel/")[1]
              .split("?")[0]
              .split("/")[0];
            videoUrl = `https://www.youtube.com/embed/videoseries?list=UU${channelId.substring(2)}`;
          }
        }
      }

      keysystemVideoFrame.src = videoUrl;
      keysystemVideo.style.display = "block";
    } else {
      keysystemVideo.style.display = "none";
      keysystemVideoFrame.src = "";
    }

    let targetUrl;
    if (keysystemData?.continue === "href") {
      targetUrl = exploit.href;
    } else if (keysystemData?.continue === "priceHref") {
      targetUrl = exploit.priceHref;
    } else {
      targetUrl = buttonType === "price" ? exploit.priceHref : exploit.href;
    }

    keysystemText.textContent =
      keysystemData?.desc || "Are you sure you want to visit this website?";

    keysystemModal.style.display = "flex";
    document.body.style.overflow = "hidden";
    keysystemModal.classList.add("active");

    if (this.isProcessingQueue) {
      this.updateModalCounter(
        okayBtn,
        this.currentModalIndex,
        this.modalQueue.length,
      );
    } else {
      okayBtn.textContent = "Okay";
    }

    const cleanup = () => {
      if (keysystemVideoFrame) {
        keysystemVideoFrame.src = "";
      }

      keysystemModal.classList.remove("active");
      setTimeout(() => {
        keysystemModal.style.display = "none";
        document.body.style.overflow = "";
      }, 300);
    };

    cancelBtn.onclick = () => {
      cleanup();
      if (this.isProcessingQueue) {
        this.modalQueue = [];
        this.currentModalIndex = 0;
        this.isProcessingQueue = false;
      }
    };

    okayBtn.onclick = () => {
      cleanup();
      setTimeout(() => {
        if (this.isProcessingQueue) {
          this.proceedToNextModal();
        } else {
          if (targetUrl) {
            window.open(targetUrl, "_blank");
          }
        }
      }, 300);
    };

    const overlay = keysystemModal.querySelector(".warning-modal-overlay");
    if (overlay) {
      overlay.onclick = () => {
        cleanup();
        if (this.isProcessingQueue) {
          this.modalQueue = [];
          this.currentModalIndex = 0;
          this.isProcessingQueue = false;
        }
      };
    }
  }

  static async showDowntimeModal(exploit, buttonType = "website") {
    const downtimeModal = document.getElementById("downtimeModal");
    const downtimeData = exploit.downtime;

    const downtimeText = document.getElementById("downtimeModalText");
    const downtimeTitle = document.getElementById("downtimeModalTitle");
    const downtimeIcon = document.getElementById("downtimeModalIcon");
    const downtimeVideo = document.getElementById("downtimeModalVideo");
    const downtimeVideoFrame = document.getElementById(
      "downtimeModalVideoFrame",
    );
    const cancelBtn = document.getElementById("downtimeModalCancel");
    const okayBtn = document.getElementById("downtimeModalOkay");

    // Get exploit status for platform replacement
    const exploitStatus = await getExploitStatus(exploit.id);
    const unupdatedPlatformsString = getUnupdatedPlatformsString(exploitStatus);

    if (downtimeData?.title) {
      downtimeTitle.textContent = downtimeData.title.replace(
        /{unupdated_platforms}/g,
        unupdatedPlatformsString,
      );
    } else {
      downtimeTitle.textContent = "Warning";
    }

    if (downtimeData?.icon) {
      downtimeIcon.src = downtimeData.icon;
      downtimeIcon.style.display = "inline-block";
    } else {
      downtimeIcon.style.display = "none";
    }

    if (downtimeData?.video) {
      let videoUrl = downtimeData.video;

      if (videoUrl.includes("youtube.com") || videoUrl.includes("youtu.be")) {
        if (videoUrl.includes("watch?v=")) {
          const videoId = videoUrl.split("watch?v=")[1].split("&")[0];
          videoUrl = `https://www.youtube.com/embed/${videoId}`;
        } else if (videoUrl.includes("youtu.be/")) {
          const videoId = videoUrl.split("youtu.be/")[1].split("?")[0];
          videoUrl = `https://www.youtube.com/embed/${videoId}`;
        } else if (videoUrl.includes("/channel/")) {
          const channelId = videoUrl
            .split("/channel/")[1]
            .split("?")[0]
            .split("/")[0];
          videoUrl = `https://www.youtube.com/embed/videoseries?list=UU${channelId.substring(2)}`;
        } else if (videoUrl.includes("you.tube")) {
          videoUrl = videoUrl.replace("you.tube", "www.youtube.com");
          if (videoUrl.includes("/channel/")) {
            const channelId = videoUrl
              .split("/channel/")[1]
              .split("?")[0]
              .split("/")[0];
            videoUrl = `https://www.youtube.com/embed/videoseries?list=UU${channelId.substring(2)}`;
          }
        }
      }

      downtimeVideoFrame.src = videoUrl;
      downtimeVideo.style.display = "block";
    } else {
      downtimeVideo.style.display = "none";
      downtimeVideoFrame.src = "";
    }

    let targetUrl;
    if (downtimeData?.continue === "href") {
      targetUrl = exploit.href;
    } else if (downtimeData?.continue === "priceHref") {
      targetUrl = exploit.priceHref;
    } else {
      targetUrl = buttonType === "price" ? exploit.priceHref : exploit.href;
    }

    const descText =
      downtimeData?.desc || "Are you sure you want to visit this website?";
    downtimeText.textContent = descText.replace(
      /{unupdated_platforms}/g,
      unupdatedPlatformsString,
    );

    downtimeModal.style.display = "flex";
    document.body.style.overflow = "hidden";
    downtimeModal.classList.add("active");

    if (this.isProcessingQueue) {
      this.updateModalCounter(
        okayBtn,
        this.currentModalIndex,
        this.modalQueue.length,
      );
    } else {
      okayBtn.textContent = "Okay";
    }

    const cleanup = () => {
      if (downtimeVideoFrame) {
        downtimeVideoFrame.src = "";
      }

      downtimeModal.classList.remove("active");
      setTimeout(() => {
        downtimeModal.style.display = "none";
        document.body.style.overflow = "";
      }, 300);
    };

    cancelBtn.onclick = () => {
      cleanup();
      if (this.isProcessingQueue) {
        this.modalQueue = [];
        this.currentModalIndex = 0;
        this.isProcessingQueue = false;
      }
    };

    okayBtn.onclick = () => {
      cleanup();
      setTimeout(() => {
        if (this.isProcessingQueue) {
          this.proceedToNextModal();
        } else {
          if (targetUrl) {
            window.open(targetUrl, "_blank");
          }
        }
      }, 300);
    };

    const overlay = downtimeModal.querySelector(".warning-modal-overlay");
    if (overlay) {
      overlay.onclick = () => {
        cleanup();
        if (this.isProcessingQueue) {
          this.modalQueue = [];
          this.currentModalIndex = 0;
          this.isProcessingQueue = false;
        }
      };
    }
  }

  static async fetchUncData(id, name) {
    try {
      const response = await fetch(`https://voxlis.net/assets/unc/${id}.json`);

      if (response.status === 404) {
        ModalManager.showNotification(
          `UNC/sUNC test for ${name} is unknown`,
          "error",
        );
        throw new Error("UNC data not found");
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const rawText = await response.text();
      return { code: rawText };
    } catch (error) {
      console.error("Error fetching UNC data:", error);
      throw error;
    }
  }

  static showNotification(message, type = "error") {
    let container = document.getElementById("custom-notifications");

    if (!container) {
      container = document.createElement("div");
      container.id = "custom-notifications";
      container.style.position = "fixed";
      container.style.top = "20px";
      container.style.right = "20px";
      container.style.zIndex = "9999";
      container.style.display = "flex";
      container.style.flexDirection = "column";
      container.style.gap = "10px";
      document.body.appendChild(container);
    }

    const notification = document.createElement("div");
    notification.className = `custom-notification ${type}`;
    notification.style.position = "relative";
    notification.style.minWidth = "320px";
    notification.style.maxWidth = "450px";
    notification.style.overflow = "hidden";
    notification.style.borderRadius = "12px";

    notification.style.boxShadow =
      "0 10px 25px -5px rgba(0, 0, 0, 0.3), 0 5px 10px -5px rgba(0, 0, 0, 0.2)";
    notification.style.transform = "translateX(120%)";
    notification.style.transition =
      "transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.5s ease";
    notification.style.margin = "0 0 10px 0";
    notification.style.opacity = "1";

    const bgColor =
      type === "error" ? "rgba(239, 68, 68, 0.85)" : "rgba(59, 130, 246, 0.85)";
    notification.style.background = bgColor;
    notification.style.backdropFilter = "blur(10px)";
    notification.style.border =
      type === "error"
        ? "1px solid rgba(248, 113, 113, 0.4)"
        : "1px solid rgba(96, 165, 250, 0.4)";

    const content = document.createElement("div");
    content.style.padding = "16px 20px";
    content.style.display = "flex";
    content.style.alignItems = "flex-start";
    content.style.gap = "15px";
    content.style.position = "relative";
    content.style.zIndex = "1";

    const decorativeLine = document.createElement("div");
    decorativeLine.style.position = "absolute";
    decorativeLine.style.top = "0";
    decorativeLine.style.left = "0";
    decorativeLine.style.width = "4px";
    decorativeLine.style.height = "100%";
    decorativeLine.style.background = "rgba(255, 255, 255, 0.9)";
    decorativeLine.style.borderRadius = "2px";
    content.appendChild(decorativeLine);

    const iconContainer = document.createElement("div");
    iconContainer.style.display = "flex";
    iconContainer.style.alignItems = "center";
    iconContainer.style.justifyContent = "center";
    iconContainer.style.width = "32px";
    iconContainer.style.height = "32px";
    iconContainer.style.borderRadius = "50%";
    iconContainer.style.flexShrink = "0";

    const icon = document.createElement("i");
    icon.className =
      type === "error" ? "fas fa-exclamation-circle" : "fas fa-info-circle";
    icon.style.color = "white";
    icon.style.fontSize = "16px";
    iconContainer.appendChild(icon);

    const messageContainer = document.createElement("div");
    messageContainer.style.flex = "1";

    const title = document.createElement("div");
    title.textContent =
      type === "error" ? "UNC Test Unavailable" : "Information";
    title.style.fontWeight = "600";
    title.style.fontSize = "14px";
    title.style.color = "white";
    title.style.marginBottom = "4px";
    title.style.letterSpacing = "0.3px";

    const messageText = document.createElement("div");
    messageText.textContent = message;
    messageText.style.fontSize = "13px";
    messageText.style.color = "rgba(255, 255, 255, 0.9)";
    messageText.style.lineHeight = "1.4";

    messageContainer.appendChild(title);
    messageContainer.appendChild(messageText);

    const closeBtn = document.createElement("button");
    closeBtn.innerHTML = '<i class="fas fa-times"></i>';
    closeBtn.style.background = "none";
    closeBtn.style.border = "none";
    closeBtn.style.color = "white";
    closeBtn.style.opacity = "0.7";
    closeBtn.style.cursor = "pointer";
    closeBtn.style.fontSize = "14px";
    closeBtn.style.padding = "4px";
    closeBtn.style.marginLeft = "8px";
    closeBtn.style.transition = "all 0.2s";
    closeBtn.style.display = "flex";
    closeBtn.style.alignItems = "center";
    closeBtn.style.justifyContent = "center";
    closeBtn.style.width = "24px";
    closeBtn.style.height = "24px";
    closeBtn.style.borderRadius = "50%";

    closeBtn.addEventListener("mouseover", () => {
      closeBtn.style.opacity = "1";
      closeBtn.style.background = "rgba(255, 255, 255, 0.2)";
    });

    closeBtn.addEventListener("mouseout", () => {
      closeBtn.style.opacity = "0.7";
      closeBtn.style.background = "none";
    });

    closeBtn.addEventListener("click", () => {
      notification.style.transform = "translateX(120%)";
      notification.style.opacity = "0";

      setTimeout(() => {
        notification.remove();
      }, 500);
    });

    content.appendChild(iconContainer);
    content.appendChild(messageContainer);
    notification.appendChild(content);

    const progressBarContainer = document.createElement("div");
    progressBarContainer.style.position = "absolute";
    progressBarContainer.style.bottom = "0";
    progressBarContainer.style.left = "0";
    progressBarContainer.style.width = "100%";
    progressBarContainer.style.height = "3px";
    progressBarContainer.style.background = "rgba(0, 0, 0, 0.1)";

    const progressBar = document.createElement("div");
    progressBar.style.height = "100%";
    progressBar.style.width = "100%";
    progressBar.style.background = "rgba(255, 255, 255, 0.7)";
    progressBar.style.transition = "width 5s cubic-bezier(0.1, 0.5, 0.2, 1)";

    progressBarContainer.appendChild(progressBar);
    notification.appendChild(progressBarContainer);

    container.appendChild(notification);

    setTimeout(() => {
      notification.style.transform = "translateX(0)";
    }, 10);

    setTimeout(() => {
      progressBar.style.width = "0";
    }, 100);

    setTimeout(() => {
      notification.style.transform = "translateX(120%)";
      notification.style.opacity = "0";

      setTimeout(() => {
        notification.remove();
      }, 5000);
    });
  }
}

class ThemeManager {
  constructor() {
    this.currentTheme = localStorage.getItem("voxlis-theme") || "red";
  }

  init() {
    document.documentElement.setAttribute("data-theme", this.currentTheme);

    this.updateLogo();
    this.setupThemeDropdown();
    this.updateThemeElements();

    return this;
  }

  setupThemeDropdown() {
    const themeDropdown = document.getElementById("themeDropdown");
    const themeDropdownSelected = document.getElementById(
      "themeDropdownSelected",
    );
    const themeDropdownOptions = document.getElementById(
      "themeDropdownOptions",
    );

    if (themeDropdown && themeDropdownSelected && themeDropdownOptions) {
      this.updateSelectedTheme(
        document.documentElement.getAttribute("data-theme") || "red",
      );

      themeDropdownSelected.addEventListener("click", () => {
        themeDropdown.classList.toggle("active");
      });

      document.addEventListener("click", (e) => {
        if (!themeDropdown.contains(e.target)) {
          themeDropdown.classList.remove("active");
        }
      });

      const themeOptions = themeDropdownOptions.querySelectorAll(
        ".theme-dropdown-option",
      );

      themeOptions.forEach((option) => {
        option.addEventListener("click", () => {
          const theme = option.getAttribute("data-theme");
          document.documentElement.setAttribute("data-theme", theme);
          this.currentTheme = theme;
          this.updateSelectedTheme(theme);
          localStorage.setItem("voxlis-theme", theme);
          this.createThemeChangeEffect(theme);
          setTimeout(() => this.updateThemeElements(), this.updateLogo(), 100);
        });
      });
    }
  }

  updateSelectedTheme(theme) {
    const themeDropdownSelected = document.getElementById(
      "themeDropdownSelected",
    );
    const themeDropdownOptions = document.getElementById(
      "themeDropdownOptions",
    );

    if (themeDropdownSelected && themeDropdownOptions) {
      const themeName = theme.charAt(0).toUpperCase() + theme.slice(1);

      themeDropdownSelected.innerHTML = `
    <div class="theme-color-indicator ${theme}"></div>
    <span>${themeName} Theme</span>
    <i class="fas fa-chevron-down"></i>
`;

      const options = themeDropdownOptions.querySelectorAll(
        ".theme-dropdown-option",
      );

      options.forEach((option) => {
        option.classList.remove("selected");

        if (option.getAttribute("data-theme") === theme) {
          option.classList.add("selected");
        }
      });
    }
  }

  createThemeChangeEffect(theme) {
    const themeColor = getComputedStyle(document.documentElement)
      .getPropertyValue("--theme-color")
      .trim();

    const ripple = document.createElement("div");
    ripple.style.position = "fixed";
    ripple.style.top = "50%";
    ripple.style.left = "50%";
    ripple.style.transform = "translate(-50%, -50%)";
    ripple.style.width = "10px";
    ripple.style.height = "10px";
    ripple.style.borderRadius = "50%";
    ripple.style.backgroundColor = themeColor;
    ripple.style.transition = "all 0.6s cubic-bezier(0.19, 1, 0.22, 1)";
    ripple.style.zIndex = "9999";

    document.body.appendChild(ripple);

    setTimeout(() => {
      ripple.style.width = "300vw";
      ripple.style.height = "300vh";
      ripple.style.opacity = "0";
    }, 10);

    setTimeout(() => {
      ripple.remove();
    }, 800);
  }

  updateLogo() {
    const logoSelectors = [
      ".logo-img",
      ".footer-logo-img",
      ".loading-logo-img",
    ];

    const adSelectors = [
      'img[src*="ad-red-voxlis"]',
      'img[src*="ad-purple-voxlis"]',
    ];

    const voxlisAdSelectors = [
      'img[src*="voxlis_small.png"]',
      'img[src*="voxlis_big.png"]',
      'img[src*="_voxlis_small.png"]',
      'img[src*="_voxlis_big.png"]',
    ];

    if (
      window.heartAnimation &&
      typeof window.heartAnimation.updateHeartImage === "function" &&
      !window.heartAnimation.isLoadingTheme
    ) {
      window.heartAnimation.updateHeartImage(this.currentTheme);
    }

    logoSelectors.forEach((selector) => {
      const logoImg = document.querySelector(selector);
      if (logoImg) {
        const themeLogoPath = `/assets/ads/${this.currentTheme}_voxlis.png`;
        const defaultLogoPath = "/assets/ads/header.png";

        const testImg = new Image();
        testImg.onload = () => {
          logoImg.src = themeLogoPath;
        };
        testImg.onerror = () => {
          logoImg.src = defaultLogoPath;
        };
        testImg.src = themeLogoPath;
      }
    });

    adSelectors.forEach((selector) => {
      const adImgs = document.querySelectorAll(selector);
      adImgs.forEach((adImg) => {
        const themeAdPath = `/assets/ads/ad-${this.currentTheme}-voxlis.png`;
        const defaultAdPath = "/assets/ads/ad-red-voxlis.png";

        const testImg = new Image();
        testImg.onload = () => {
          adImg.src = themeAdPath;
        };
        testImg.onerror = () => {
          adImg.src = defaultAdPath;
        };
        testImg.src = themeAdPath;
      });
    });

    voxlisAdSelectors.forEach((selector) => {
      const adImgs = document.querySelectorAll(selector);
      adImgs.forEach((adImg) => {
        const currentSrc = adImg.src;
        let newSrc;

        if (
          currentSrc.includes("voxlis_small.png") ||
          currentSrc.includes("_voxlis_small.png")
        ) {
          newSrc = `/assets/ads/${this.currentTheme}_voxlis_small.png`;
        } else if (
          currentSrc.includes("voxlis_big.png") ||
          currentSrc.includes("_voxlis_big.png")
        ) {
          newSrc = `/assets/ads/${this.currentTheme}_voxlis_big.png`;
        }

        if (newSrc) {
          const testImg = new Image();
          testImg.onload = () => {
            adImg.src = newSrc;
          };
          testImg.onerror = () => {
            const fallbackSrc = newSrc.replace(`${this.currentTheme}_`, "red_");
            adImg.src = fallbackSrc;
          };
          testImg.src = newSrc;
        }
      });
    });
  }
  updateThemeElements() {
    const theme = this.currentTheme;
    let bgColor, textColor, borderColor;

    const uncModal = document.querySelector(".unc-modal");

    if (uncModal) {
      uncModal.style.backgroundColor = bgColor;
      uncModal.style.color = textColor;
      uncModal.style.border = `1px solid ${borderColor}`;

      const modalHeader = uncModal.querySelector(".unc-modal-header");
      if (modalHeader) {
        modalHeader.style.borderBottom = `1px solid ${borderColor}`;
      }

      const modalFooter = uncModal.querySelector(".unc-modal-footer");
      if (modalFooter) {
        modalFooter.style.borderTop = `1px solid ${borderColor}`;
      }
    }

    const infoModal = document.querySelector(".info-modal");

    if (infoModal) {
      const header = infoModal.querySelector(".info-modal-header");
      if (header) {
        header.style.background = "";
        header.style.borderBottom = "";
      }

      const exploitName = infoModal.querySelector(".info-modal-exploit-name");
      if (exploitName) {
        exploitName.style.background = "";
      }

      const closeBtn = infoModal.querySelector(".info-modal-close-btn");
      if (closeBtn) {
        closeBtn.style.backgroundColor = "";
      }

      const links = infoModal.querySelectorAll(".info-modal-markdown a");
      links.forEach((link) => {
        link.style.color = "";
      });

      const blockquote = infoModal.querySelectorAll(
        ".info-modal-markdown blockquote",
      );
      blockquote.forEach((bq) => {
        bq.style.backgroundColor = "";
        bq.style.borderColor = "";
        bq.style.color = "";
      });

      const codeBlocks = infoModal.querySelectorAll(
        ".info-modal-markdown pre code",
      );
      codeBlocks.forEach((codeBlock) => {
        codeBlock.style.background = "";
        codeBlock.style.color = "";
      });
    }

    const webButtons = document.querySelectorAll(".web-btn");
    webButtons.forEach((btn) => {
      btn.style.backgroundColor = "";
      btn.style.borderColor = "";
      btn.style.color = "";
    });

    const heroElements = document.querySelectorAll(
      ".hero-acnt-bar, .hero-ttl strong, .hero-ttl b, .hero-ttl em, .yt-tutorial-btn",
    );

    heroElements.forEach((el) => {
      el.style.background = "";
      el.style.color = "";
    });

    const checkboxes = document.querySelectorAll(
      ".cstm-chkbx.ext input:checked ~ .chkmrk, .cstm-chkbx.exec input:checked ~ .chkmrk",
    );

    checkboxes.forEach((cb) => {
      cb.style.backgroundColor = "";
      cb.style.borderColor = "";
    });
  }
}

class OptimizedHeartAnimation {
  constructor({ heartCount = 30, minHearts = 15 } = {}) {
    if (OptimizedHeartAnimation.instance) {
      return OptimizedHeartAnimation.instance;
    }
    OptimizedHeartAnimation.instance = this;

    this.canvas = document.getElementById("heartRainCanvas");
    this.loader = document.getElementById("loader");
    if (!this.canvas) return;

    // <CHANGE> Enable desynchronized for better performance
    this.ctx = this.canvas.getContext("2d", {
      alpha: true,
      desynchronized: true,
    });
    const currentTheme =
      document.documentElement.getAttribute("data-theme") || "red";
    this.heartImageSrc = `/assets/ads/${currentTheme}-heart.svg`;
    this.hearts = [];
    this.heartImage = new Image();
    this.isRunning = false;
    this.isLoadingTheme = false;
    // <CHANGE> Add flag to pause animation during theme switch
    this.isSwitchingTheme = false;
    this.lastFrameTime = 0;
    // <CHANGE> Increased from 20 to 30 for smoother animation
    this.targetFps = 30;
    this.fpsInterval = 1000 / this.targetFps;
    this.frameSkipCounter = 0;
    // <CHANGE> Reduced from 3 to 2
    this.maxFrameSkip = 2;

    this.baseHeartCount = heartCount;
    this.minHearts = minHearts;
    this.maxClickHearts = 15;
    this.maxTotalHearts = 30;

    this.cssWidth = 0;
    this.cssHeight = 0;
    this.isVisible = true;
    this.animationId = null;
    this.isInitialized = false;

    // <CHANGE> Increased from 5 to 10 for better batching
    this.batchSize = 10;
    this.updateBatch = 0;

    this.init();
  }

  init() {
    if (this.isInitialized) return;
    this.isInitialized = true;

    this.resizeCanvas();

    if (typeof ResizeObserver !== "undefined") {
      this.resizeObserver = new ResizeObserver(() => this.resizeCanvas());
      this.resizeObserver.observe(this.canvas);
    } else {
      this.resizeHandler = this.resizeCanvas.bind(this);
      window.addEventListener("resize", this.resizeHandler);
    }

    this.visibilityHandler = () => {
      this.isVisible = !document.hidden;
      if (this.isVisible && this.isRunning) {
        this.lastFrameTime = performance.now();
        this.animate(this.lastFrameTime);
      }
    };
    document.addEventListener("visibilitychange", this.visibilityHandler);

    this.lastClickTime = 0;
    this.clickThrottle = 100;
    this.clickHandler = (e) => {
      const now = performance.now();
      if (now - this.lastClickTime < this.clickThrottle) return;
      this.lastClickTime = now;
      this.handleClick(e);
    };
    this.canvas.addEventListener("click", this.clickHandler);

    this.loadHeartImage();
  }

  loadHeartImage() {
    this.heartImage.onload = () => {
      if (this.loader) this.loader.style.display = "none";
      this.generateInitialHearts();
      this.start();
    };

    this.heartImage.onerror = () => {
      this.heartImageSrc = "/assets/ads/red-heart.svg";
      this.heartImage.src = this.heartImageSrc;
      this.heartImage.onload = () => {
        if (this.loader) this.loader.style.display = "none";
        this.generateInitialHearts();
        this.start();
      };
    };

    this.heartImage.src = this.heartImageSrc;
  }

  generateInitialHearts() {
    const target = this.getEffectiveBaseCount();
    this.hearts = [];
    for (let i = 0; i < target; i++) {
      this.hearts.push(this.createHeart());
    }
  }

  getEffectiveBaseCount() {
    const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
    const screenArea =
      (this.cssWidth || window.innerWidth) *
      (this.cssHeight || window.innerHeight);
    const scaleFactor = Math.min(1, screenArea / 1000000);
    return Math.max(
      this.minHearts,
      Math.round((this.baseHeartCount * scaleFactor) / dpr),
    );
  }

  updateHeartImage(theme) {
    if (this.isLoadingTheme || this.isSwitchingTheme) return;

    this.isSwitchingTheme = true;
    this.isLoadingTheme = true;

    // Stop animation completely during theme switch
    const wasRunning = this.isRunning;
    if (wasRunning) {
      this.stop();
    }

    const themeHeartPath = `/assets/ads/${theme}-heart.svg`;
    const newHeartImage = new Image();

    newHeartImage.onload = () => {
      // Wait for next frame to ensure rendering pipeline is clear
      requestAnimationFrame(() => {
        this.heartImageSrc = themeHeartPath;
        this.heartImage = newHeartImage;

        // Batch update hearts to prevent massive repaints when zoomed out
        const batchSize = 10;
        let index = 0;

        const updateBatch = () => {
          const end = Math.min(index + batchSize, this.hearts.length);
          for (let i = index; i < end; i++) {
            this.hearts[i].img = this.heartImage;
          }
          index = end;

          if (index < this.hearts.length) {
            requestAnimationFrame(updateBatch);
          } else {
            // All hearts updated, resume animation
            this.isLoadingTheme = false;
            setTimeout(() => {
              this.isSwitchingTheme = false;
              if (wasRunning) {
                this.lastFrameTime = performance.now();
                this.start();
              }
            }, 50);
          }
        };

        updateBatch();
      });
    };

    newHeartImage.onerror = () => {
      const fallbackImage = new Image();
      fallbackImage.onload = () => {
        requestAnimationFrame(() => {
          this.heartImageSrc = "/assets/ads/red-heart.svg";
          this.heartImage = fallbackImage;

          const batchSize = 10;
          let index = 0;

          const updateBatch = () => {
            const end = Math.min(index + batchSize, this.hearts.length);
            for (let i = index; i < end; i++) {
              this.hearts[i].img = this.heartImage;
            }
            index = end;

            if (index < this.hearts.length) {
              requestAnimationFrame(updateBatch);
            } else {
              this.isLoadingTheme = false;
              setTimeout(() => {
                this.isSwitchingTheme = false;
                if (wasRunning) {
                  this.lastFrameTime = performance.now();
                  this.start();
                }
              }, 50);
            }
          };

          updateBatch();
        });
      };
      fallbackImage.src = "/assets/ads/red-heart.svg";
    };

    newHeartImage.src = themeHeartPath;
  }

  resizeCanvas() {
    if (!this.canvas) return;

    const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
    const oldCssWidth =
      this.cssWidth || this.canvas.clientWidth || window.innerWidth;
    const oldCssHeight =
      this.cssHeight || this.canvas.clientHeight || window.innerHeight;

    this.cssWidth = this.canvas.clientWidth || window.innerWidth;
    this.cssHeight = this.canvas.clientHeight || window.innerHeight;

    this.canvas.width = Math.floor(this.cssWidth * dpr);
    this.canvas.height = Math.floor(this.cssHeight * dpr);
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    if (this.hearts.length && oldCssWidth && oldCssHeight) {
      const scaleX = this.cssWidth / oldCssWidth;
      const scaleY = this.cssHeight / oldCssHeight;
      this.hearts.forEach((h) => {
        h.x *= scaleX;
        h.y *= scaleY;
      });
    }

    this.adjustHeartCount();
  }

  adjustHeartCount() {
    const target = this.getEffectiveBaseCount();
    const baseHearts = this.hearts.filter((h) => !h.isClickHeart);

    if (baseHearts.length < target) {
      const toAdd = target - baseHearts.length;
      for (let i = 0; i < toAdd; i++) {
        this.hearts.push(this.createHeart());
      }
    } else if (baseHearts.length > target) {
      let toRemove = baseHearts.length - target;
      for (let i = this.hearts.length - 1; i >= 0 && toRemove > 0; i--) {
        if (!this.hearts[i].isClickHeart) {
          this.hearts.splice(i, 1);
          toRemove--;
        }
      }
    }

    if (this.hearts.length > this.maxTotalHearts) {
      this.hearts = this.hearts.slice(0, this.maxTotalHearts);
    }
  }

  createHeart() {
    return {
      img: this.heartImage,
      x: Math.random() * (this.cssWidth || window.innerWidth),
      y: Math.random() * (this.cssHeight || window.innerHeight),
      dx: Math.random() * 0.4 - 0.2,
      dy: Math.random() * 0.3 + 0.2,
      size: Math.random() * 15 + 15,
      rotation: Math.random() * 0.2 - 0.1,
      rotationSpeed: Math.random() * 0.005 - 0.0025,
      opacity: Math.random() * 0.3 + 0.7,
      isClickHeart: false,
    };
  }

  start() {
    if (!this.isRunning) {
      this.isRunning = true;
      this.lastFrameTime = performance.now();
      this.animationId = requestAnimationFrame(this.animate.bind(this));
    }
  }

  stop() {
    this.isRunning = false;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }

  animate(timestamp) {
    // <CHANGE> Skip animation if switching theme
    if (!this.isRunning || !this.isVisible || this.isSwitchingTheme) {
      if (this.isRunning && !this.isSwitchingTheme) {
        this.animationId = requestAnimationFrame(this.animate.bind(this));
      }
      return;
    }

    const elapsed = timestamp - this.lastFrameTime;

    if (elapsed < this.fpsInterval) {
      this.animationId = requestAnimationFrame(this.animate.bind(this));
      return;
    }

    // <CHANGE> Improved frame skip logic
    if (elapsed > this.fpsInterval * 2) {
      this.frameSkipCounter++;
      if (this.frameSkipCounter < this.maxFrameSkip) {
        this.lastFrameTime = timestamp;
        this.animationId = requestAnimationFrame(this.animate.bind(this));
        return;
      }
      this.frameSkipCounter = 0;
    } else {
      this.frameSkipCounter = 0;
    }

    this.lastFrameTime = timestamp - (elapsed % this.fpsInterval);
    this.ctx.clearRect(0, 0, this.cssWidth, this.cssHeight);

    // <CHANGE> Simplified batch processing - removed complex batching
    for (let i = this.hearts.length - 1; i >= 0; i--) {
      const h = this.hearts[i];
      this.updateHeart(h, i);
      this.drawHeart(h);
    }

    this.animationId = requestAnimationFrame(this.animate.bind(this));
  }

  updateHeart(h, index) {
    h.x += h.dx;
    h.y += h.dy;
    h.rotation += h.rotationSpeed;

    if (h.isClickHeart) {
      h.life -= 1;
      h.opacity = Math.max(0, h.life / h.maxLife);
      h.dy += 0.015;
      if (h.life <= 0) {
        this.hearts.splice(index, 1);
        return;
      }
    } else {
      const limitX = this.cssWidth + h.size;
      const limitY = this.cssHeight + h.size;
      if (h.y > limitY) {
        h.y = -h.size;
        h.x = Math.random() * this.cssWidth;
        h.dy = Math.random() * 0.15 + 0.075;
      }
      if (h.x < -h.size) h.x = this.cssWidth + h.size;
      if (h.x > this.cssWidth + h.size) h.x = -h.size;
    }
  }

  // <CHANGE> Optimized drawing to skip rotation when not needed
  drawHeart(h) {
    this.ctx.globalAlpha = h.opacity;

    // Only rotate if rotation is significant (reduces GPU operations)
    if (Math.abs(h.rotation) > 0.01) {
      this.ctx.save();
      this.ctx.translate(h.x, h.y);
      this.ctx.rotate(h.rotation);
      this.ctx.drawImage(h.img, -h.size / 2, -h.size / 2, h.size, h.size);
      this.ctx.restore();
    } else {
      this.ctx.drawImage(
        h.img,
        h.x - h.size / 2,
        h.y - h.size / 2,
        h.size,
        h.size,
      );
    }
  }

  handleClick(e) {
    const clickHearts = this.hearts.filter((h) => h.isClickHeart);
    if (
      clickHearts.length >= this.maxClickHearts ||
      this.hearts.length >= this.maxTotalHearts
    )
      return;

    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const n = Math.floor(Math.random() * 2) + 1;

    for (let i = 0; i < n && this.hearts.length < this.maxTotalHearts; i++) {
      const maxLife = 30 + Math.floor(Math.random() * 15);
      this.hearts.push({
        img: this.heartImage,
        x: x + (Math.random() * 20 - 10),
        y: y + (Math.random() * 20 - 10),
        dx: Math.random() * 1 - 0.5,
        dy: Math.random() * -1 - 0.3,
        size: Math.random() * 20 + 20,
        rotation: Math.random() * 0.02 - 0.01,
        // <CHANGE> Reduced click heart rotation speed significantly
        rotationSpeed: Math.random() * 0.01 - 0.005,
        opacity: 1,
        isClickHeart: true,
        life: maxLife,
        maxLife,
      });
    }
  }

  destroy() {
    this.stop();

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    } else if (this.resizeHandler) {
      window.removeEventListener("resize", this.resizeHandler);
    }

    if (this.visibilityHandler) {
      document.removeEventListener("visibilitychange", this.visibilityHandler);
    }

    if (this.clickHandler) {
      this.canvas.removeEventListener("click", this.clickHandler);
    }

    this.hearts = [];
    OptimizedHeartAnimation.instance = null;
  }
}

if (typeof window !== "undefined") {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      window.heartAnimation = new OptimizedHeartAnimation();
    });
  } else {
    window.heartAnimation = new OptimizedHeartAnimation();
  }
}

class LoadingManager {
  constructor(appState) {
    this.appState = appState;
    this.loadingBar = document.getElementById("loadingBar");
    this.loadingScreen = document.getElementById("loadingScreen");
    this.loadingText = document.querySelector(".loading-text");
  }

  init() {
    let progress = 0;
    const startTime = performance.now();
    const deviceTier = this.appState.performanceMonitor.deviceTier;

    const isSlowDevice = () => this.appState.performanceMonitor.isLowEndDevice;
    const incrementAmount = isSlowDevice()
      ? 2
      : deviceTier === "medium"
        ? 4
        : 8;
    const incrementInterval = isSlowDevice()
      ? 150
      : deviceTier === "medium"
        ? 100
        : 60;

    if (this.loadingText) {
      this.loadingText.textContent = `Detecting device performance (${deviceTier})...`;
    }

    const loadingInterval = setInterval(() => {
      if (progress < 100) {
        progress += incrementAmount;

        if (progress > 100) progress = 100;

        requestAnimationFrame(() => {
          if (this.loadingBar) this.loadingBar.style.width = `${progress}%`;
        });

        if (this.loadingText) {
          if (progress < 30) {
            this.loadingText.textContent = `Loading click data (${deviceTier} mode)...`;
          } else if (progress < 60) {
            this.loadingText.textContent = `Loading exploits status (${deviceTier} mode)...`;
          } else if (progress < 90) {
            this.loadingText.textContent = `Almost ready (${deviceTier} mode)...`;
          } else {
            const totalTime = performance.now() - startTime;
            this.loadingText.textContent = `Loaded in ${totalTime.toFixed(0)}ms (${deviceTier} mode)`;
          }
        }
      } else {
        clearInterval(loadingInterval);

        setTimeout(
          () => {
            if (this.loadingScreen) {
              this.loadingScreen.style.transition =
                "opacity 0.8s ease, visibility 0.8s ease";
              this.loadingScreen.style.opacity = "0";
              this.loadingScreen.style.visibility = "hidden";

              setTimeout(() => {
                this.loadingScreen.remove();
              }, 800);
            }
          },
          isSlowDevice() ? 1000 : deviceTier === "medium" ? 600 : 300,
        );
      }
    }, incrementInterval);

    return this;
  }
}

class FloatingWarningSystem {
  constructor() {
    this.warning = document.getElementById("floatingWarning");
    if (!this.warning) return;

    this.isVisible = false;
    this.lastScrollY = window.pageYOffset;
    this.scrollThreshold = 15;

    this.hideTimeout = null;
    this.userClosed = false;

    this.init();
  }

  init() {
    if (sessionStorage.getItem("warningClosed") === "true") {
      this.userClosed = true;
      this.warning.style.display = "none";
      return;
    }
    setTimeout(() => this.showWarning(), 1500);
    this.setupScrollListener();
  }

  setupScrollListener() {}
  handleScroll() {
    if (this.userClosed) return;
    const currentScrollY = window.pageYOffset;
    const isAtTop = currentScrollY < 50;
    const isScrollingUp = currentScrollY < this.lastScrollY;
    const isScrollingDown = currentScrollY > this.lastScrollY;

    if (isAtTop) {
      if (this.isVisible) this.hideWarning();
    } else if (isScrollingUp) {
      if (!this.isVisible) this.showWarning();
    } else if (
      isScrollingDown &&
      Math.abs(currentScrollY - this.lastScrollY) > this.scrollThreshold
    ) {
      if (this.isVisible) this.hideWarning();
    }
    this.lastScrollY = currentScrollY <= 0 ? 0 : currentScrollY;
  }

  showWarning() {
    if (this.isVisible || this.userClosed) return;
    this.warning.classList.add("is-visible");
    this.isVisible = true;
    clearTimeout(this.hideTimeout);
    this.hideTimeout = setTimeout(() => this.hideWarning(), 8000);
  }

  hideWarning() {
    if (!this.isVisible) return;
    this.warning.classList.remove("is-visible");
    this.isVisible = false;
    clearTimeout(this.hideTimeout);
  }

  close() {
    this.hideWarning();
    this.userClosed = true;
    sessionStorage.setItem("warningClosed", "true");
  }
}

class TopWarningBar {
  constructor() {
    this.warningBar = document.getElementById("topWarningBar");
    if (!this.warningBar) return;

    this.userClosed = false;
    this.warningBarHeight = 0;

    this.init();
  }

  init() {
    if (sessionStorage.getItem("topWarningClosed") === "true") {
      this.userClosed = true;
      this.warningBar.style.display = "none";
      document.body.classList.remove("has-top-warning");
      return;
    }

    this.warningBarHeight = this.warningBar.offsetHeight;
    document.documentElement.style.setProperty(
      "--warning-bar-height",
      `${this.warningBarHeight}px`,
    );

    document.body.classList.add("has-top-warning");
  }

  setupScrollListener() {
    let ticking = false;
    window.addEventListener("scroll", () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          this.handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    });
  }

  setupTransitionListener() {
    this.warningBar.addEventListener("transitionend", (e) => {
      if (e.propertyName === "transform" && !this.isVisible) {
        document.body.classList.remove("has-top-warning");
      }
    });
  }

  handleScroll() {
    if (this.userClosed) return;
    const isAtTop = window.pageYOffset <= this.topThreshold;
    if (isAtTop && !this.isVisible) {
      this.showWarning();
    }
  }

  showWarning() {
    if (this.isVisible || this.userClosed) return;
    document.body.classList.add("has-top-warning");
    this.warningBar.offsetHeight;
    this.warningBar.classList.add("is-visible");
    this.isVisible = true;
  }

  hideWarning() {
    if (!this.isVisible) return;
    this.warningBar.classList.remove("is-visible");
    this.isVisible = false;
  }

  close() {
    this.hideWarning();
    this.userClosed = true;
    sessionStorage.setItem("topWarningClosed", "true");
  }
}

let floatingWarningInstance;
let topWarningBarInstance;

document.addEventListener("DOMContentLoaded", () => {
  floatingWarningInstance = new FloatingWarningSystem();
  topWarningBarInstance = new TopWarningBar();
});

document.addEventListener("DOMContentLoaded", async () => {
  const appState = new AppState();

  await appState.init();

  const uiManager = new UIManager(appState).init();
  const themeManager = new ThemeManager().init();
  const loadingManager = new LoadingManager(appState).init();
  window.heartAnimation = new OptimizedHeartAnimation();

  clickTracker = appState.clickTracker;

  setTimeout(() => {
    uiManager.setupCardButtons();
  }, 500);

  console.log(
    `Device performance tier: ${appState.performanceMonitor.deviceTier}`,
  );
  console.log(
    `Low-end device: ${appState.performanceMonitor.isLowEndDevice ? "Yes" : "No"}`,
  );
});

window.addEventListener("load", () => {
  setTimeout(() => {
    if (clickTracker) {
      clickTracker.retryFailedClicks();
    }
  }, 5000);
});

window.addEventListener("load", () => {
  if ("performance" in window) {
    const perfData = performance.getEntriesByType("navigation")[0];
    console.log("Page load performance:", {
      domContentLoaded:
        perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
      loadComplete: perfData.loadEventEnd - perfData.loadEventStart,
      totalTime: perfData.loadEventEnd - perfData.fetchStart,
    });
  }
});

// Platform Badges Stacking and Spreading System
// This system manages the interactive stacking and spreading behavior of platform badges
// (Windows, macOS, iOS, Android icons) displayed on exploit cards.
// This is like, a lot trickier than it seems.
class PlatformBadgesManager {
  constructor() {
    this.badgeProximity = [15, 15]; // [horizontal, vertical] proximity for normal badges
    this.statusDownProximity = [0, 15]; // [horizontal, vertical] proximity for status-down badges
    this.containerStates = new Map(); // Track spread-down state per container to prevent flickering
    this.init();
  }

  init() {
    this.setupBadgeStacking();
    this.setupHoverDetection();

    // Re-setup when new badges are added to DOM
    const observer = new MutationObserver(() => {
      this.setupBadgeStacking();
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

  setupBadgeStacking() {
    const allBadgeContainers = document.querySelectorAll('.pltf-bdgs');

    allBadgeContainers.forEach(container => {
      const badges = container.querySelectorAll('.pltf-bdg');

      // Set z-index for each badge (rightmost has highest z-index)
      // Also identify groups of status-down badges
      let prevWasDown = false;

      badges.forEach((badge, index) => {
        badge.style.zIndex = index + 1;

        const isDown = badge.classList.contains('status-down');

        // Mark the first badge in a status-down group
        if (isDown && !prevWasDown) {
          badge.classList.add('group-start');
        } else if (isDown && prevWasDown) {
          badge.classList.remove('group-start');
        } else {
          badge.classList.remove('group-start');
        }

        prevWasDown = isDown;
      });
    });
  }

  setupHoverDetection() {
    let rafId = null;

    const checkHover = (e) => {
      if (rafId) {
        cancelAnimationFrame(rafId);
      }

      rafId = requestAnimationFrame(() => {
        const allBadgeContainers = document.querySelectorAll('.pltf-bdgs');

        allBadgeContainers.forEach(container => {
          const rect = container.getBoundingClientRect();
          const mouseX = e.clientX;
          const mouseY = e.clientY;

          // Check proximity to main badge container using separate horizontal/vertical thresholds
          const horizontalDistance = this.getHorizontalDistanceToRect(mouseX, rect);
          const verticalDistance = this.getVerticalDistanceToRect(mouseY, rect);

          const nearMainBadges =
            horizontalDistance <= this.badgeProximity[0] &&
            verticalDistance <= this.badgeProximity[1];

          // If within proximity threshold of container, spread the main badges
          if (nearMainBadges) {
            container.classList.add('spread');

            // Check if there's a status-down container and if we're near it
            const downContainer = container.querySelector('.pltf-bdgs-down');
            let nearDownContainer = false;

            if (downContainer) {
              const downRect = downContainer.getBoundingClientRect();
              const downHorizontalDistance = this.getHorizontalDistanceToRect(mouseX, downRect);
              const downVerticalDistance = this.getVerticalDistanceToRect(mouseY, downRect);

              nearDownContainer =
                downHorizontalDistance <= this.statusDownProximity[0] &&
                downVerticalDistance <= this.statusDownProximity[1];
            }

            // Get or initialize state for this container
            if (!this.containerStates.has(container)) {
              this.containerStates.set(container, { isSpreadDown: false, frameCount: 0 });
            }
            const state = this.containerStates.get(container);

            // Require nearDownContainer to be true for multiple consecutive frames before spreading
            // This prevents flickering during badge position transitions
            if (nearDownContainer) {
              state.frameCount++;
              // Only spread after 2 consecutive frames of being near
              if (state.frameCount >= 2 || state.isSpreadDown) {
                container.classList.add('spread-down');
                state.isSpreadDown = true;
              }
            } else {
              // Immediately unspread when not near
              state.frameCount = 0;
              state.isSpreadDown = false;
              container.classList.remove('spread-down');
            }
          } else {
            // Reset state when leaving proximity
            if (this.containerStates.has(container)) {
              this.containerStates.get(container).frameCount = 0;
              this.containerStates.get(container).isSpreadDown = false;
            }
            container.classList.remove('spread');
            container.classList.remove('spread-down');
          }
        });
      });
    };

    document.addEventListener('mousemove', checkHover, { passive: true });
  }

  getDistanceToRect(x, y, rect) {
    // Calculate the shortest distance from point (x, y) to rectangle
    const dx = Math.max(rect.left - x, 0, x - rect.right);
    const dy = Math.max(rect.top - y, 0, y - rect.bottom);
    return Math.sqrt(dx * dx + dy * dy);
  }

  getVerticalDistanceToRect(y, rect) {
    // Calculate only the vertical distance from point y to rectangle
    // Ignores horizontal distance completely
    return Math.max(rect.top - y, 0, y - rect.bottom);
  }

  getHorizontalDistanceToRect(x, rect) {
    // Calculate only the horizontal distance from point x to rectangle
    // Ignores vertical distance completely
    return Math.max(rect.left - x, 0, x - rect.right);
  }
}

// Initialize Platform Badges Manager
document.addEventListener('DOMContentLoaded', () => {
  new PlatformBadgesManager();
});

class ReportManager {
  static init() {
    const reportBtn = document.getElementById("reportBtn");
    const mobReportBtn = document.getElementById("mobReportBtn");
    const reportModal = document.getElementById("reportModal");
    const reportModalClose = document.getElementById("reportModalClose");
    const reportCancelBtn = document.getElementById("reportCancelBtn");
    const reportForm = document.getElementById("reportForm");
    const reportModalOverlay = document.querySelector(".report-modal-overlay");

    if (reportBtn) {
      reportBtn.addEventListener("click", ReportManager.openModal);
    }

    if (mobReportBtn) {
      mobReportBtn.addEventListener("click", ReportManager.openModal);
    }

    if (reportModalClose) {
      reportModalClose.addEventListener("click", ReportManager.closeModal);
    }

    if (reportCancelBtn) {
      reportCancelBtn.addEventListener("click", ReportManager.closeModal);
    }

    if (reportModalOverlay) {
      reportModalOverlay.addEventListener("click", ReportManager.closeModal);
    }

    if (reportForm) {
      reportForm.addEventListener("submit", ReportManager.handleSubmit);
    }

    document.addEventListener("keydown", (e) => {
      if (
        e.key === "Escape" &&
        reportModal &&
        reportModal.classList.contains("active")
      ) {
        ReportManager.closeModal();
      }
    });
  }

  static openModal() {
    const modal = document.getElementById("reportModal");
    if (modal) {
      modal.style.display = "flex";
      setTimeout(() => {
        modal.classList.add("active");
      }, 10);
      document.body.style.overflow = "hidden";
    }
  }

  static closeModal() {
    const modal = document.getElementById("reportModal");
    if (modal) {
      modal.classList.remove("active");
      setTimeout(() => {
        modal.style.display = "none";
        document.body.style.overflow = "";
        ReportManager.resetForm();
      }, 300);
    }
  }

  static resetForm() {
    const form = document.getElementById("reportForm");
    if (form) {
      form.reset();
    }
  }

  static async handleSubmit(e) {
    e.preventDefault();

    const lastReport = localStorage.getItem("lastReportTime");
    const now = Date.now();
    const fifteenMinutes = 15 * 60 * 1000;

    if (lastReport && now - Number.parseInt(lastReport) < fifteenMinutes) {
      const remainingTime = Math.ceil(
        (fifteenMinutes - (now - Number.parseInt(lastReport))) / 60000,
      );
      return;
    }

    const sendBtn = document.getElementById("reportSendBtn");
    const title = document.getElementById("reportTitle").value.trim();
    const description = document
      .getElementById("reportDescription")
      .value.trim();

    if (!title || !description) {
      return;
    }

    sendBtn.disabled = true;
    sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sending...';

    try {
      const response = await fetch("https://api.voxlis.net/report-voxlis.php", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          title: title,
          description: description,
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          url: window.location.href,
          referrer: document.referrer || "Direct",
        }),
      });

      const result = await response.json();

      if (result.success) {
        localStorage.setItem("lastReportTime", now.toString());

        ReportManager.closeModal();
      } else {
        throw new Error(result.message || "Failed to submit report");
      }
    } catch (error) {
      console.error("Report submission error:", error);
    } finally {
      sendBtn.disabled = false;
      sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i> Send Report';
    }
  }
}

document.addEventListener("DOMContentLoaded", () => {
  ReportManager.init();
});

class MobileMenuManager {
  constructor() {
    this.menu = document.getElementById("mobMenu");
    this.menuToggle = document.getElementById("mobMenuTgl");
    this.closeButton = null;
    this.isAnimating = false;

    this.init();
  }

  init() {
    this.addCloseButton();

    this.setupEventListeners();

    if (this.menuToggle) {
      this.menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
    }
  }

  addCloseButton() {
    if (!this.menu) return;

    const menuContainer = this.menu.querySelector(".mob-menu-cntr");
    if (!menuContainer) return;

    let closeButton = document.getElementById("mobMenuClose");
    if (!closeButton) {
      closeButton = document.createElement("button");
      closeButton.id = "mobMenuClose";
      closeButton.className = "mob-menu-close";
      closeButton.innerHTML = '<i class="fas fa-times"></i>';

      menuContainer.insertBefore(closeButton, menuContainer.firstChild);
    }

    this.closeButton = closeButton;
  }

  setupEventListeners() {
    if (this.closeButton) {
      this.closeButton.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.closeMenu();
      });
    }

    if (this.menu) {
      this.menu.addEventListener("click", (e) => {
        if (e.target === this.menu) {
          this.closeMenu();
        }
      });
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && !this.menu.classList.contains("hidden")) {
        this.closeMenu();
      }
    });

    // Close mobile menu on resize to larger screens
    let resizeTimeout;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (window.innerWidth > 1024 && this.menu && !this.menu.classList.contains("hidden")) {
          this.menu.classList.add("hidden");
          document.body.classList.remove("menu-open");
          document.body.style.overflow = "";
          this.isAnimating = false;
        }
      }, 100);
    });
  }

  closeMenu() {
    if (
      this.isAnimating ||
      !this.menu ||
      this.menu.classList.contains("hidden")
    ) {
      return;
    }

    this.isAnimating = true;

    this.menu.style.transform = "translateY(-100%)";
    this.menu.style.opacity = "0";

    setTimeout(() => {
      this.menu.classList.add("hidden");
      document.body.classList.remove("menu-open");
      document.body.style.overflow = "";

      this.menu.style.transform = "";
      this.menu.style.opacity = "";

      this.isAnimating = false;
    }, 450);
  }

  openMenu() {
    if (
      this.isAnimating ||
      !this.menu ||
      !this.menu.classList.contains("hidden")
    ) {
      return;
    }

    this.isAnimating = true;

    this.menu.classList.remove("hidden");
    document.body.classList.add("menu-open");
    document.body.style.overflow = "hidden";

    setTimeout(() => {
      this.isAnimating = false;
    }, 450);
  }
}

document.addEventListener("DOMContentLoaded", () => {
  window.mobileMenuManager = new MobileMenuManager();

  const menuToggle = document.getElementById("mobMenuTgl");
  const menu = document.getElementById("mobMenu");

  if (menuToggle && menu) {
    const newMenuToggle = menuToggle.cloneNode(true);
    menuToggle.parentNode.replaceChild(newMenuToggle, menuToggle);

    newMenuToggle.addEventListener("click", () => {
      if (menu.classList.contains("hidden")) {
        window.mobileMenuManager.openMenu();
      } else {
        window.mobileMenuManager.closeMenu();
      }
    });
  }
});

// Custom scroll behavior for exploit cards
class CardScrollManager {
  constructor() {
    this.scrollIntervals = new Map();
    this.init();
  }

  init() {
    document.addEventListener('DOMContentLoaded', () => {
      this.setupCardScrollBehavior();
    });

    // Also run immediately in case DOM is already loaded
    if (document.readyState === 'loading') {
      // Wait for DOM
    } else {
      this.setupCardScrollBehavior();
    }
  }

  setupCardScrollBehavior() {
    // Use event delegation for better performance
    const observer = new MutationObserver(() => {
      this.attachScrollHandlers();
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    this.attachScrollHandlers();
  }

  attachScrollHandlers() {
    const cards = document.querySelectorAll('.exp-crd');

    cards.forEach(card => {
      // Skip if already initialized
      if (card.dataset.scrollInitialized) return;
      card.dataset.scrollInitialized = 'true';

      const content = card.querySelector('.crd-cntnt');
      const cardBody = card.querySelector('.crd-bdy');
      if (!content || !cardBody) return;

      // Check if content has overflow and add class to card body
      const checkOverflow = () => {
        const hasOverflow = content.scrollHeight > content.clientHeight;
        if (hasOverflow) {
          cardBody.classList.add('has-overflow');
        } else {
          cardBody.classList.remove('has-overflow');
        }
      };

      // Check overflow initially and on resize
      checkOverflow();
      const resizeObserver = new ResizeObserver(checkOverflow);
      resizeObserver.observe(content);

      // Reset scroll to top when mouse leaves the card
      card.addEventListener('mouseleave', () => {
        content.scrollTop = 0;
        this.stopAutoScroll(content);
        cardBody.classList.remove('hovering-scroll-indicator');
      });

      // Handle mouse movement within card body to detect hover over indicator
      cardBody.addEventListener('mousemove', (e) => {
        const rect = cardBody.getBoundingClientRect();
        const mouseY = e.clientY - rect.top;
        const indicatorHeight = 30; // Match CSS height

        // Check if hovering over the bottom indicator area
        if (rect.height - mouseY <= indicatorHeight) {
          cardBody.classList.add('hovering-scroll-indicator');
          this.startAutoScroll(content);
        } else {
          cardBody.classList.remove('hovering-scroll-indicator');
          this.stopAutoScroll(content);
        }
      });

      cardBody.addEventListener('mouseleave', () => {
        cardBody.classList.remove('hovering-scroll-indicator');
        this.stopAutoScroll(content);
      });
    });
  }

  startAutoScroll(element) {
    // Don't start if already scrolling
    if (this.scrollIntervals.has(element)) return;

    // Immediately scroll to bottom
    const maxScroll = element.scrollHeight - element.clientHeight;
    element.scrollTop = maxScroll;

    this.scrollIntervals.set(element, true); // Mark as scrolled
  }

  stopAutoScroll(element) {
    if (this.scrollIntervals.has(element)) {
      clearInterval(this.scrollIntervals.get(element));
      this.scrollIntervals.delete(element);
    }
  }
}

// Initialize card scroll manager
new CardScrollManager();
